//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroid\src\main\java\r\android\animation\ValueAnimator.java
//

#import <Foundation/Foundation.h>
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ValueAnimator")
#ifdef RESTRICT_ValueAnimator
#define INCLUDE_ALL_ValueAnimator 0
#else
#define INCLUDE_ALL_ValueAnimator 1
#endif
#undef RESTRICT_ValueAnimator

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ADValueAnimator_) && (INCLUDE_ALL_ValueAnimator || defined(INCLUDE_ADValueAnimator))
#define ADValueAnimator_

#define RESTRICT_Animator 1
#define INCLUDE_ADAnimator 1
#include "Animator.h"

#define RESTRICT_AnimationHandler 1
#define INCLUDE_ADAnimationHandler_AnimationFrameCallback 1
#include "AnimationHandler.h"

@class ADAnimationHandler;
@class IOSFloatArray;
@class IOSIntArray;
@class IOSObjectArray;
@class JavaLangBoolean;
@class JavaLangFloat;
@class JavaLangInteger;
@class JavaLangLong;
@class JavaUtilArrayList;
@class JavaUtilHashMap;
@class NSString;
@protocol ADTimeInterpolator;
@protocol ADTypeEvaluator;
@protocol ADValueAnimator_AnimatorUpdateListener;
@protocol ADValueAnimator_DurationScaleChangeListener;

/*!
 @brief This class provides a simple timing engine for running animations
  which calculate animated values and set them on target objects.
 <p>There is a single timing pulse that all animations use. It runs in a
  custom handler to ensure that property changes happen on the UI thread.</p>
  
 <p>By default, ValueAnimator uses non-linear time interpolation, via the 
 <code>AccelerateDecelerateInterpolator</code> class, which accelerates into and decelerates
  out of an animation. This behavior can be changed by calling 
 <code>ValueAnimator.setInterpolator(TimeInterpolator)</code>.</p>
  
 <p>Animators can be created from either code or resource files. Here is an example
  of a ValueAnimator resource file:</p>
  
 development/samples/ApiDemos/res/anim/animator.xml ValueAnimatorResources
  
 <p>Starting from API 23, it is also possible to use a combination of <code>PropertyValuesHolder</code>
  and <code>Keyframe</code> resource tags to create a multi-step animation.
  Note that you can specify explicit fractional values (from 0 to 1) for
  each keyframe to determine when, in the overall duration, the animation should arrive at that
  value. Alternatively, you can leave the fractions off and the keyframes will be equally
  distributed within the total duration:</p>
  
 development/samples/ApiDemos/res/anim/value_animator_pvh_kf.xml
  ValueAnimatorKeyframeResources
  
 <div class="special reference">
  <h3>Developer Guides</h3>
  <p>For more information about animating with <code>ValueAnimator</code>, read the 
 <a href="{@@docRoot}guide/topics/graphics/prop-animation.html#value-animator">Property
  Animation</a> developer guide.</p>
  </div>
 */
@interface ADValueAnimator : ADAnimator < ADAnimationHandler_AnimationFrameCallback > {
 @public
  /*!
   @brief The first time that the animation's animateFrame() method is called.This time is used to
  determine elapsed time (and therefore the elapsed fraction) in subsequent calls
  to animateFrame().
   Whenever mStartTime is set, you must also update mStartTimeCommitted.
   */
  int64_t mStartTime_;
  /*!
   @brief When true, the start time has been firmly committed as a chosen reference point in
  time by which the progress of the animation will be evaluated.When false, the
  start time may be updated when the first animation frame is committed so as
  to compensate for jank that may have occurred between when the start time was
  initialized and when the frame was actually drawn.
   This flag is generally set to false during the first frame of the animation
  when the animation playing state transitions from STOPPED to RUNNING or
  resumes after having been paused.  This flag is set to true when the start time
  is firmly committed and should not be further compensated for jank.
   */
  bool mStartTimeCommitted_;
  /*!
   @brief Set when setCurrentPlayTime() is called.If negative, animation is not currently seeked
  to a value.
   */
  float mSeekFraction_;
  /*!
   @brief Flag that denotes whether the animation is set up and ready to go.Used to
  set up animation that has not yet been started.
   */
  bool mInitialized_;
  /*!
   @brief The set of listeners to be sent events through the life of an animation.
   */
  JavaUtilArrayList *mUpdateListeners_;
  /*!
   @brief The property/value sets being animated.
   */
  IOSObjectArray *mValues_;
  /*!
   @brief A hashmap of the PropertyValuesHolder objects.This map is used to lookup animated values
  by property name during calls to getAnimatedValue(String).
   */
  JavaUtilHashMap *mValuesMap_;
}

#pragma mark Public

/*!
 @brief Creates a new ValueAnimator object.This default constructor is primarily for
  use internally; the factory methods which take parameters are more generally
  useful.
 */
- (instancetype)init;

/*!
 @brief Adds a listener to the set of listeners that are sent update events through the life of
  an animation.This method is called on all listeners for every frame of the animation,
  after the values for the animation have been calculated.
 @param listener the listener to be added to the current set of listeners for this animation.
 */
- (void)addUpdateListenerWithADValueAnimator_AnimatorUpdateListener:(id<ADValueAnimator_AnimatorUpdateListener>)listener;

/*!
 @brief Returns whether animators are currently enabled, system-wide.By default, all
  animators are enabled.
 This can change if either the user sets a Developer Option
  to set the animator duration scale to 0 or by Battery Savery mode being enabled
  (which disables all animations). 
 <p>Developers should not typically need to call this method, but should an app wish
  to show a different experience when animators are disabled, this return value
  can be used as a decider of which experience to offer.
 @return boolean Whether animators are currently enabled. The default value is 
 <code>true</code>.
 */
+ (bool)areAnimatorsEnabled;

- (void)cancel;

/*!
 */
- (bool)canReverse;

- (ADValueAnimator *)java_clone;

/*!
 @brief Applies an adjustment to the animation to compensate for jank between when
  the animation first ran and when the frame was drawn.
 */
- (void)commitAnimationFrameWithLong:(int64_t)frameTime;

/*!
 @brief Processes a frame of the animation, adjusting the start time if needed.
 @param frameTime The frame time.
 @return true if the animation has ended.
 */
- (bool)doAnimationFrameWithLong:(int64_t)frameTime;

- (void)end;

/*!
 @brief Returns the current animation fraction, which is the elapsed/interpolated fraction used in
  the most recent frame update on the animation.
 @return Elapsed/interpolated fraction of the animation.
 */
- (float)getAnimatedFraction;

/*!
 @brief The most recent value calculated by this <code>ValueAnimator</code> when there is just one
  property being animated.This value is only sensible while the animation is running.
 The main
  purpose for this read-only property is to retrieve the value from the <code>ValueAnimator</code>
  during a call to <code>AnimatorUpdateListener.onAnimationUpdate(ValueAnimator)</code>, which
  is called during each animation frame, immediately after the value is calculated.
 @return animatedValue The value most recently calculated by this <code>ValueAnimator</code> for
  the single property being animated. If there are several properties being animated
  (specified by several PropertyValuesHolder objects in the constructor), this function
  returns the animated value for the first of those objects.
 */
- (id)getAnimatedValue;

/*!
 @brief The most recent value calculated by this <code>ValueAnimator</code> for <code>propertyName</code>.
 The main purpose for this read-only property is to retrieve the value from the 
 <code>ValueAnimator</code> during a call to 
 <code>AnimatorUpdateListener.onAnimationUpdate(ValueAnimator)</code>, which
  is called during each animation frame, immediately after the value is calculated.
 @return animatedValue The value most recently calculated for the named property
  by this <code>ValueAnimator</code>.
 */
- (id)getAnimatedValueWithNSString:(NSString *)propertyName;

/*!
 @return The <code>AnimationHandler</code> that will be used to schedule updates for this animator.
 */
- (ADAnimationHandler *)getAnimationHandler;

/*!
 @brief Return the number of animations currently running.
 Used by StrictMode internally to annotate violations.
  May be called on arbitrary threads!
 */
+ (int32_t)getCurrentAnimationsCount;

/*!
 @brief Gets the current position of the animation in time, which is equal to the current
  time minus the time that the animation started.An animation that is not yet started will
  return a value of zero, unless the animation has has its play time set via 
 <code>setCurrentPlayTime(long)</code> or <code>setCurrentFraction(float)</code>, in which case
  it will return the time that was set.
 @return The current position in time of the animation.
 */
- (int64_t)getCurrentPlayTime;

/*!
 @brief Gets the length of the animation.The default duration is 300 milliseconds.
 @return The length of the animation, in milliseconds.
 */
- (int64_t)getDuration;

/*!
 @brief Returns the system-wide scaling factor for Animator-based animations.
 This affects both the start delay and duration of all such animations. Setting to 0 will
  cause animations to end immediately. The default value is 1.0f.
 @return the duration scale.
 */
+ (float)getDurationScale;

/*!
 @brief The amount of time, in milliseconds, between each frame of the animation.This is a
  requested time that the animation will attempt to honor, but the actual delay between
  frames may be different, depending on system load and capabilities.
 This is a static
  function because the same delay will be applied to all animations, since they are all
  run off of a single timing loop.
  The frame delay may be ignored when the animation system uses an external timing
  source, such as the display refresh rate (vsync), to govern animations.
  Note that this method should be called from the same thread that <code>start()</code> is
  called in order to check the frame delay for that animation. A runtime exception will be
  thrown if the calling thread does not have a Looper.
 @return the requested time between frames, in milliseconds
 */
+ (int64_t)getFrameDelay;

/*!
 @brief Returns the timing interpolator that this ValueAnimator uses.
 @return The timing interpolator for this ValueAnimator.
 */
- (id<ADTimeInterpolator>)getInterpolator;

/*!
 @brief Defines how many times the animation should repeat.The default value
  is 0.
 @return the number of times the animation should repeat, or <code>INFINITE</code>
 */
- (int32_t)getRepeatCount;

/*!
 @brief Defines what this animation should do when it reaches the end.
 @return either one of <code>REVERSE</code> or <code>RESTART</code>
 */
- (int32_t)getRepeatMode;

/*!
 @brief The amount of time, in milliseconds, to delay starting the animation after 
 <code>start()</code> is called.
 @return the number of milliseconds to delay running the animation
 */
- (int64_t)getStartDelay;

- (int64_t)getTotalDuration;

/*!
 @brief Returns the values that this ValueAnimator animates between.These values are stored in
  PropertyValuesHolder objects, even if the ValueAnimator was created with a simple list
  of value objects instead.
 @return PropertyValuesHolder[] An array of PropertyValuesHolder objects which hold the
  values, per property, that define the animation.
 */
- (IOSObjectArray *)getValues;

- (bool)isRunning;

- (bool)isStarted;

/*!
 @brief Constructs and returns a ValueAnimator that animates between color values.A single
  value implies that that value is the one being animated to.
 However, this is not typically
  useful in a ValueAnimator object because there is no way for the object to determine the
  starting value for the animation (unlike ObjectAnimator, which can derive that value
  from the target object and property being animated). Therefore, there should typically
  be two or more values.
 @param values A set of values that the animation will animate between over time.
 @return A ValueAnimator object that is set up to animate between the given values.
 */
+ (ADValueAnimator *)ofArgbWithIntArray:(IOSIntArray *)values;

/*!
 @brief Constructs and returns a ValueAnimator that animates between float values.A single
  value implies that that value is the one being animated to.
 However, this is not typically
  useful in a ValueAnimator object because there is no way for the object to determine the
  starting value for the animation (unlike ObjectAnimator, which can derive that value
  from the target object and property being animated). Therefore, there should typically
  be two or more values.
 @param values A set of values that the animation will animate between over time.
 @return A ValueAnimator object that is set up to animate between the given values.
 */
+ (ADValueAnimator *)ofFloatWithFloatArray:(IOSFloatArray *)values;

/*!
 @brief Constructs and returns a ValueAnimator that animates between int values.A single
  value implies that that value is the one being animated to.
 However, this is not typically
  useful in a ValueAnimator object because there is no way for the object to determine the
  starting value for the animation (unlike ObjectAnimator, which can derive that value
  from the target object and property being animated). Therefore, there should typically
  be two or more values.
 @param values A set of values that the animation will animate between over time.
 @return A ValueAnimator object that is set up to animate between the given values.
 */
+ (ADValueAnimator *)ofIntWithIntArray:(IOSIntArray *)values;

/*!
 @brief Constructs and returns a ValueAnimator that animates between Object values.A single
  value implies that that value is the one being animated to.
 However, this is not typically
  useful in a ValueAnimator object because there is no way for the object to determine the
  starting value for the animation (unlike ObjectAnimator, which can derive that value
  from the target object and property being animated). Therefore, there should typically
  be two or more values. 
 <p><strong>Note:</strong> The Object values are stored as references to the original
  objects, which means that changes to those objects after this method is called will
  affect the values on the animator. If the objects will be mutated externally after
  this method is called, callers should pass a copy of those objects instead. 
 <p>Since ValueAnimator does not know how to animate between arbitrary Objects, this
  factory method also takes a TypeEvaluator object that the ValueAnimator will use
  to perform that interpolation.
 @param evaluator A TypeEvaluator that will be called on each animation frame to  provide the ncessry interpolation between the Object values to derive the animated
   value.
 @param values A set of values that the animation will animate between over time.
 @return A ValueAnimator object that is set up to animate between the given values.
 */
+ (ADValueAnimator *)ofObjectWithADTypeEvaluator:(id<ADTypeEvaluator>)evaluator
                               withNSObjectArray:(IOSObjectArray *)values;

/*!
 @brief Constructs and returns a ValueAnimator that animates between the values
  specified in the PropertyValuesHolder objects.
 @param values A set of PropertyValuesHolder objects whose values will be animated  between over time.
 @return A ValueAnimator object that is set up to animate between the given values.
 */
+ (ADValueAnimator *)ofPropertyValuesHolderWithADPropertyValuesHolderArray:(IOSObjectArray *)values;

/*!
 @brief Overrides the global duration scale by a custom value.
 @param durationScale The duration scale to set; or <code>-1f</code>  to use the global duration                       scale.
 */
- (void)overrideDurationScaleWithFloat:(float)durationScale;

- (void)pause;

/*!
 @brief Registers a <code>DurationScaleChangeListener</code>
  This listens for changes to the system-wide scaling factor for Animator-based animations.
 Listeners will be called on the main thread.
 @param listener the listener to register.
 @return true if the listener was registered.
 */
+ (bool)registerDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener:(id<ADValueAnimator_DurationScaleChangeListener>)listener;

/*!
 @brief Removes all listeners from the set listening to frame updates for this animation.
 */
- (void)removeAllUpdateListeners;

/*!
 @brief Removes a listener from the set listening to frame updates for this animation.
 @param listener the listener to be removed from the current set of update listeners  for this animation.
 */
- (void)removeUpdateListenerWithADValueAnimator_AnimatorUpdateListener:(id<ADValueAnimator_AnimatorUpdateListener>)listener;

- (void)resume;

/*!
 @brief Plays the ValueAnimator in reverse.If the animation is already running,
  it will stop itself and play backwards from the point reached when reverse was called.
 If the animation is not currently running, then it will start from the end and
  play backwards. This behavior is only set for the current animation; future playing
  of the animation will use the default behavior of playing forward.
 */
- (void)reverse;

/*!
 @brief <p>Whether or not the ValueAnimator is allowed to run asynchronously off of
  the UI thread.This is a hint that informs the ValueAnimator that it is
  OK to run the animation off-thread, however ValueAnimator may decide
  that it must run the animation on the UI thread anyway.
 For example if there
  is an <code>AnimatorUpdateListener</code> the animation will run on the UI thread,
  regardless of the value of this hint.</p>
  
 <p>Regardless of whether or not the animation runs asynchronously, all
  listener callbacks will be called on the UI thread.</p>
  
 <p>To be able to use this hint the following must be true:</p>
  <ol>
  <li><code>getAnimatedFraction()</code> is not needed (it will return undefined values).</li>
  <li>The animator is immutable while <code>isStarted()</code> is true. Requests
     to change values, duration, delay, etc... may be ignored.</li>
  <li>Lifecycle callback events may be asynchronous. Events such as
     <code>Animator.AnimatorListener.onAnimationEnd(Animator)</code> or
     <code>Animator.AnimatorListener.onAnimationRepeat(Animator)</code> may end up delayed
     as they must be posted back to the UI thread, and any actions performed
     by those callbacks (such as starting new animations) will not happen
     in the same frame.</li>
  <li>State change requests (<code>cancel()</code>, <code>end()</code>, <code>reverse()</code>, etc...)
     may be asynchronous. It is guaranteed that all state changes that are
     performed on the UI thread in the same frame will be applied as a single
     atomic update, however that frame may be the current frame,
     the next frame, or some future frame. This will also impact the observed
     state of the Animator. For example, <code>isStarted()</code> may still return true
     after a call to <code>end()</code>. Using the lifecycle callbacks is preferred over
     queries to <code>isStarted()</code>, <code>isRunning()</code>, and <code>isPaused()</code>
     for this reason.</li>
  </ol>
 */
- (void)setAllowRunningAsynchronouslyWithBoolean:(bool)mayRunAsync;

/*!
 @brief Sets the animation handler used to schedule updates for this animator or <code>null</code> to use
  the default handler.
 */
- (void)setAnimationHandlerWithADAnimationHandler:(ADAnimationHandler *)animationHandler;

/*!
 @brief Sets the position of the animation to the specified fraction.This fraction should
  be between 0 and the total fraction of the animation, including any repetition.
 That is,
  a fraction of 0 will position the animation at the beginning, a value of 1 at the end,
  and a value of 2 at the end of a reversing animator that repeats once. If
  the animation has not yet been started, then it will not advance forward after it is
  set to this fraction; it will simply set the fraction to this value and perform any
  appropriate actions based on that fraction. If the animation is already running, then
  setCurrentFraction() will set the current fraction to this value and continue
  playing from that point. <code>Animator.AnimatorListener</code> events are not called
  due to changing the fraction; those events are only processed while the animation
  is running.
 @param fraction The fraction to which the animation is advanced or rewound. Values  outside the range of 0 to the maximum fraction for the animator will be clamped to
   the correct range.
 */
- (void)setCurrentFractionWithFloat:(float)fraction;

/*!
 @brief Sets the position of the animation to the specified point in time.This time should
  be between 0 and the total duration of the animation, including any repetition.
 If
  the animation has not yet been started, then it will not advance forward after it is
  set to this time; it will simply set the time to this value and perform any appropriate
  actions based on that time. If the animation is already running, then setCurrentPlayTime()
  will set the current playing time to this value and continue playing from that point.
 @param playTime The time, in milliseconds, to which the animation is advanced or rewound.
 */
- (void)setCurrentPlayTimeWithLong:(int64_t)playTime;

/*!
 @brief Sets the length of the animation.The default duration is 300 milliseconds.
 @param duration The length of the animation, in milliseconds. This value cannot  be negative.
 @return ValueAnimator The object called with setDuration(). This return
  value makes it easier to compose statements together that construct and then set the
  duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */
- (ADValueAnimator *)setDurationWithLong:(int64_t)duration;

/*!
 */
+ (void)setDurationScaleWithFloat:(float)durationScale;

/*!
 @brief The type evaluator to be used when calculating the animated values of this animation.
 The system will automatically assign a float or int evaluator based on the type
  of <code>startValue</code> and <code>endValue</code> in the constructor. But if these values
  are not one of these primitive types, or if different evaluation is desired (such as is
  necessary with int values that represent colors), a custom evaluator needs to be assigned.
  For example, when running an animation on color values, the <code>ArgbEvaluator</code>
  should be used to get correct RGB color interpolation. 
 <p>If this ValueAnimator has only one set of values being animated between, this evaluator
  will be used for that set. If there are several sets of values being animated, which is
  the case if PropertyValuesHolder objects were set on the ValueAnimator, then the evaluator
  is assigned just to the first PropertyValuesHolder object.</p>
 @param value the evaluator to be used this animation
 */
- (void)setEvaluatorWithADTypeEvaluator:(id<ADTypeEvaluator>)value;

/*!
 @brief Sets float values that will be animated between.A single
  value implies that that value is the one being animated to.
 However, this is not typically
  useful in a ValueAnimator object because there is no way for the object to determine the
  starting value for the animation (unlike ObjectAnimator, which can derive that value
  from the target object and property being animated). Therefore, there should typically
  be two or more values. 
 <p>If there are already multiple sets of values defined for this ValueAnimator via more
  than one PropertyValuesHolder object, this method will set the values for the first
  of those objects.</p>
 @param values A set of values that the animation will animate between over time.
 */
- (void)setFloatValuesWithFloatArray:(IOSFloatArray *)values;

/*!
 @brief The amount of time, in milliseconds, between each frame of the animation.This is a
  requested time that the animation will attempt to honor, but the actual delay between
  frames may be different, depending on system load and capabilities.
 This is a static
  function because the same delay will be applied to all animations, since they are all
  run off of a single timing loop.
  The frame delay may be ignored when the animation system uses an external timing
  source, such as the display refresh rate (vsync), to govern animations.
  Note that this method should be called from the same thread that <code>start()</code> is
  called in order to have the new frame delay take effect on that animation. A runtime
  exception will be thrown if the calling thread does not have a Looper.
 @param frameDelay the requested time between frames, in milliseconds
 */
+ (void)setFrameDelayWithLong:(int64_t)frameDelay;

/*!
 @brief The time interpolator used in calculating the elapsed fraction of this animation.The
  interpolator determines whether the animation runs with linear or non-linear motion,
  such as acceleration and deceleration.
 The default value is 
 <code>r.android.view.animation.AccelerateDecelerateInterpolator</code>
 @param value the interpolator to be used by this animation. A value of  <code> null </code>
   will result in linear interpolation.
 */
- (void)setInterpolatorWithADTimeInterpolator:(id<ADTimeInterpolator>)value;

/*!
 @brief Sets int values that will be animated between.A single
  value implies that that value is the one being animated to.
 However, this is not typically
  useful in a ValueAnimator object because there is no way for the object to determine the
  starting value for the animation (unlike ObjectAnimator, which can derive that value
  from the target object and property being animated). Therefore, there should typically
  be two or more values. 
 <p>If there are already multiple sets of values defined for this ValueAnimator via more
  than one PropertyValuesHolder object, this method will set the values for the first
  of those objects.</p>
 @param values A set of values that the animation will animate between over time.
 */
- (void)setIntValuesWithIntArray:(IOSIntArray *)values;

/*!
 @brief Sets the values to animate between for this animation.A single
  value implies that that value is the one being animated to.
 However, this is not typically
  useful in a ValueAnimator object because there is no way for the object to determine the
  starting value for the animation (unlike ObjectAnimator, which can derive that value
  from the target object and property being animated). Therefore, there should typically
  be two or more values. 
 <p><strong>Note:</strong> The Object values are stored as references to the original
  objects, which means that changes to those objects after this method is called will
  affect the values on the animator. If the objects will be mutated externally after
  this method is called, callers should pass a copy of those objects instead. 
 <p>If there are already multiple sets of values defined for this ValueAnimator via more
  than one PropertyValuesHolder object, this method will set the values for the first
  of those objects.</p>
  
 <p>There should be a TypeEvaluator set on the ValueAnimator that knows how to interpolate
  between these value objects. ValueAnimator only knows how to interpolate between the
  primitive types specified in the other setValues() methods.</p>
 @param values The set of values to animate between.
 */
- (void)setObjectValuesWithNSObjectArray:(IOSObjectArray *)values;

/*!
 @brief Sets how many times the animation should be repeated.If the repeat
  count is 0, the animation is never repeated.
 If the repeat count is
  greater than 0 or <code>INFINITE</code>, the repeat mode will be taken
  into account. The repeat count is 0 by default.
 @param value the number of times the animation should be repeated
 */
- (void)setRepeatCountWithInt:(int32_t)value;

/*!
 @brief Defines what this animation should do when it reaches the end.This
  setting is applied only when the repeat count is either greater than
  0 or <code>INFINITE</code>.
 Defaults to <code>RESTART</code>.
 @param value<code>RESTART</code>  or <code>REVERSE</code>
 */
- (void)setRepeatModeWithInt:(int32_t)value;

/*!
 @brief The amount of time, in milliseconds, to delay starting the animation after 
 <code>start()</code> is called.Note that the start delay should always be non-negative.
 Any
  negative start delay will be clamped to 0 on N and above.
 @param startDelay The amount of the delay, in milliseconds
 */
- (void)setStartDelayWithLong:(int64_t)startDelay;

/*!
 @brief Sets the values, per property, being animated between.This function is called internally
  by the constructors of ValueAnimator that take a list of values.
 But a ValueAnimator can
  be constructed without values and this method can be called to set the values manually
  instead.
 @param values The set of values, per property, being animated between.
 */
- (void)setValuesWithADPropertyValuesHolderArray:(IOSObjectArray *)values;

- (void)start;

- (NSString *)description;

/*!
 @brief Unregisters a DurationScaleChangeListener.
 - seealso: #registerDurationScaleChangeListener(DurationScaleChangeListener)
 @param listener the listener to unregister.
 @return true if the listener was unregistered.
 */
+ (bool)unregisterDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener:(id<ADValueAnimator_DurationScaleChangeListener>)listener;

#pragma mark Package-Private

/*!
 @brief This internal function processes a single animation frame for a given animation.The
  currentTime parameter is the timing pulse sent by the handler, used to calculate the
  elapsed duration, and therefore
  the elapsed fraction, of the animation.
 The return value indicates whether the animation
  should be ended (which happens when the elapsed time of the animation exceeds the
  animation's duration, including the repeatCount).
 @param currentTime The current time, as tracked by the static timing handler
 @return true if the animation's duration, including any repetitions due to 
 <code>repeatCount</code> has been exceeded and the animation should be ended.
 */
- (bool)animateBasedOnTimeWithLong:(int64_t)currentTime;

- (void)animateSkipToEndsWithLong:(int64_t)currentPlayTime
                         withLong:(int64_t)lastPlayTime;

/*!
 @brief This method is called with the elapsed fraction of the animation during every
  animation frame.This function turns the elapsed fraction into an interpolated fraction
  and then into an animated value (from the evaluator.
 The function is called mostly during
  animation updates, but it is also called when the <code>end()</code>
  function is called, to set the final value on the property. 
 <p>Overrides of this method must call the superclass to perform the calculation
  of the animated value.</p>
 @param fraction The elapsed fraction of the animation.
 */
- (void)animateValueWithFloat:(float)fraction;

/*!
 @brief Internal use only.
 This method does not modify any fields of the animation. It should be called when seeking
  in an AnimatorSet. When the last play time and current play time are of different repeat
  iterations, 
 <code>r.android.view.animation.Animation.AnimationListener.onAnimationRepeat(Animation)</code>
  will be called.
 */
- (void)animateValuesInRangeWithLong:(int64_t)currentPlayTime
                            withLong:(int64_t)lastPlayTime;

/*!
 @brief Returns the name of this animator for debugging purposes.
 */
- (NSString *)getNameForTrace;

/*!
 @brief This function is called immediately before processing the first animation
  frame of an animation.If there is a nonzero <code>startDelay</code>, the
  function is called after that delay ends.
 It takes care of the final initialization steps for the
  animation.
   
 <p>Overrides of this method should call the superclass method to ensure
   that internal mechanisms for the animation are set up correctly.</p>
 */
- (void)initAnimation OBJC_METHOD_FAMILY_NONE;

- (bool)isInitialized;

- (bool)pulseAnimationFrameWithLong:(int64_t)frameTime;

/*!
 @brief Internal use only.
 Skips the animation value to end/start, depending on whether the play direction is forward
  or backward.
 @param inReverse whether the end value is based on a reverse direction. If yes, this is                   equivalent to skip to start value in a forward playing direction.
 */
- (void)skipToEndValueWithBoolean:(bool)inReverse;

- (void)startWithoutPulsingWithBoolean:(bool)inReverse;

@end

J2OBJC_STATIC_INIT(ADValueAnimator)

J2OBJC_FIELD_SETTER(ADValueAnimator, mUpdateListeners_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADValueAnimator, mValues_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ADValueAnimator, mValuesMap_, JavaUtilHashMap *)

/*!
 @brief When the animation reaches the end and <code>repeatCount</code> is INFINITE
  or a positive value, the animation restarts from the beginning.
 */
inline int32_t ADValueAnimator_get_RESTART(void);
#define ADValueAnimator_RESTART 1
J2OBJC_STATIC_FIELD_CONSTANT(ADValueAnimator, RESTART, int32_t)

/*!
 @brief When the animation reaches the end and <code>repeatCount</code> is INFINITE
  or a positive value, the animation reverses direction on every iteration.
 */
inline int32_t ADValueAnimator_get_REVERSE(void);
#define ADValueAnimator_REVERSE 2
J2OBJC_STATIC_FIELD_CONSTANT(ADValueAnimator, REVERSE, int32_t)

/*!
 @brief This value used used with the <code>setRepeatCount(int)</code> property to repeat
  the animation indefinitely.
 */
inline int32_t ADValueAnimator_get_INFINITE(void);
#define ADValueAnimator_INFINITE -1
J2OBJC_STATIC_FIELD_CONSTANT(ADValueAnimator, INFINITE, int32_t)

FOUNDATION_EXPORT void ADValueAnimator_setDurationScaleWithFloat_(float durationScale);

FOUNDATION_EXPORT float ADValueAnimator_getDurationScale(void);

FOUNDATION_EXPORT bool ADValueAnimator_registerDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener_(id<ADValueAnimator_DurationScaleChangeListener> listener);

FOUNDATION_EXPORT bool ADValueAnimator_unregisterDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener_(id<ADValueAnimator_DurationScaleChangeListener> listener);

FOUNDATION_EXPORT bool ADValueAnimator_areAnimatorsEnabled(void);

FOUNDATION_EXPORT void ADValueAnimator_init(ADValueAnimator *self);

FOUNDATION_EXPORT ADValueAnimator *new_ADValueAnimator_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADValueAnimator *create_ADValueAnimator_init(void);

FOUNDATION_EXPORT ADValueAnimator *ADValueAnimator_ofIntWithIntArray_(IOSIntArray *values);

FOUNDATION_EXPORT ADValueAnimator *ADValueAnimator_ofArgbWithIntArray_(IOSIntArray *values);

FOUNDATION_EXPORT ADValueAnimator *ADValueAnimator_ofFloatWithFloatArray_(IOSFloatArray *values);

FOUNDATION_EXPORT ADValueAnimator *ADValueAnimator_ofPropertyValuesHolderWithADPropertyValuesHolderArray_(IOSObjectArray *values);

FOUNDATION_EXPORT ADValueAnimator *ADValueAnimator_ofObjectWithADTypeEvaluator_withNSObjectArray_(id<ADTypeEvaluator> evaluator, IOSObjectArray *values);

FOUNDATION_EXPORT int64_t ADValueAnimator_getFrameDelay(void);

FOUNDATION_EXPORT void ADValueAnimator_setFrameDelayWithLong_(int64_t frameDelay);

FOUNDATION_EXPORT int32_t ADValueAnimator_getCurrentAnimationsCount(void);

J2OBJC_TYPE_LITERAL_HEADER(ADValueAnimator)

@compatibility_alias RAndroidAnimationValueAnimator ADValueAnimator;


#endif

#if !defined (ADValueAnimator_RepeatMode_) && (INCLUDE_ALL_ValueAnimator || defined(INCLUDE_ADValueAnimator_RepeatMode))
#define ADValueAnimator_RepeatMode_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

/*!
 */
@protocol ADValueAnimator_RepeatMode < JavaLangAnnotationAnnotation >

@end

J2OBJC_EMPTY_STATIC_INIT(ADValueAnimator_RepeatMode)

J2OBJC_TYPE_LITERAL_HEADER(ADValueAnimator_RepeatMode)


#endif

#if !defined (ADValueAnimator_AnimatorUpdateListener_) && (INCLUDE_ALL_ValueAnimator || defined(INCLUDE_ADValueAnimator_AnimatorUpdateListener))
#define ADValueAnimator_AnimatorUpdateListener_

@class ADValueAnimator;

/*!
 @brief Implementors of this interface can add themselves as update listeners
  to an <code>ValueAnimator</code> instance to receive callbacks on every animation
  frame, after the current frame's values have been calculated for that 
 <code>ValueAnimator</code>.
 */
@protocol ADValueAnimator_AnimatorUpdateListener < JavaObject >

/*!
 @brief <p>Notifies the occurrence of another frame of the animation.
 </p>
 @param animation The animation which was repeated.
 */
- (void)onAnimationUpdateWithADValueAnimator:(ADValueAnimator *)animation;

@end

J2OBJC_EMPTY_STATIC_INIT(ADValueAnimator_AnimatorUpdateListener)

J2OBJC_TYPE_LITERAL_HEADER(ADValueAnimator_AnimatorUpdateListener)


#endif

#if !defined (ADValueAnimator_DurationScaleChangeListener_) && (INCLUDE_ALL_ValueAnimator || defined(INCLUDE_ADValueAnimator_DurationScaleChangeListener))
#define ADValueAnimator_DurationScaleChangeListener_

@class JavaLangFloat;

/*!
 @brief Listener interface for the system-wide scaling factor for Animator-based animations.
 - seealso: #registerDurationScaleChangeListener(DurationScaleChangeListener)
 - seealso: #unregisterDurationScaleChangeListener(DurationScaleChangeListener)
 */
@protocol ADValueAnimator_DurationScaleChangeListener < JavaObject >

/*!
 @brief Called when the duration scale changes.
 @param scale_ the duration scale
 */
- (void)onChangedWithFloat:(float)scale_;

@end

J2OBJC_EMPTY_STATIC_INIT(ADValueAnimator_DurationScaleChangeListener)

J2OBJC_TYPE_LITERAL_HEADER(ADValueAnimator_DurationScaleChangeListener)


#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_ValueAnimator")
