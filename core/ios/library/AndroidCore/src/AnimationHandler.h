//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroid\src\main\java\r\android\animation\AnimationHandler.java
//

#import <Foundation/Foundation.h>
#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_AnimationHandler")
#ifdef RESTRICT_AnimationHandler
#define INCLUDE_ALL_AnimationHandler 0
#else
#define INCLUDE_ALL_AnimationHandler 1
#endif
#undef RESTRICT_AnimationHandler

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ADAnimationHandler_) && (INCLUDE_ALL_AnimationHandler || defined(INCLUDE_ADAnimationHandler))
#define ADAnimationHandler_

@class ADObjectAnimator;
@class JavaLangBoolean;
@class JavaLangInteger;
@class JavaLangLong;
@class JavaLangThreadLocal;
@protocol ADAnimationHandler_AnimationFrameCallback;
@protocol ADAnimationHandler_AnimationFrameCallbackProvider;

/*!
 @brief This custom, static handler handles the timing pulse that is shared by all active
  ValueAnimators.This approach ensures that the setting of animation values will happen on the
  same thread that animations start on, and that all animations will share the same times for
  calculating their values, which makes synchronizing animations possible.
 The handler uses the Choreographer by default for doing periodic callbacks. A custom
  AnimationFrameCallbackProvider can be set on the handler to provide timing pulse that
  may be independent of UI frame update. This could be useful in testing.
 */
@interface ADAnimationHandler : NSObject

#pragma mark Public

- (instancetype)init;

/*!
 @brief Register to get a callback on the next frame after the delay.
 */
- (void)addAnimationFrameCallbackWithADAnimationHandler_AnimationFrameCallback:(id<ADAnimationHandler_AnimationFrameCallback>)callback
                                                                      withLong:(int64_t)delay;

/*!
 @brief Register to get a one shot callback for frame commit timing.Frame commit timing is the
  time *after* traversals are done, as opposed to the animation frame timing, which is
  before any traversals.
 This timing can be used to adjust the start time of an animation
  when expensive traversals create big delta between the animation frame timing and the time
  that animation is first shown on screen.
  Note this should only be called when the animation has already registered to receive
  animation frame callbacks. This callback will be guaranteed to happen *after* the next
  animation frame callback.
 */
- (void)addOneShotCommitCallbackWithADAnimationHandler_AnimationFrameCallback:(id<ADAnimationHandler_AnimationFrameCallback>)callback;

/*!
 @brief Return the number of callbacks that have registered for frame callbacks.
 */
+ (int32_t)getAnimationCount;

+ (int64_t)getFrameDelay;

+ (ADAnimationHandler *)getInstance;

/*!
 @brief Removes the given callback from the list, so it will no longer be called for frame related
  timing.
 */
- (void)removeCallbackWithADAnimationHandler_AnimationFrameCallback:(id<ADAnimationHandler_AnimationFrameCallback>)callback;

/*!
 @brief This is called when a window goes away.We should remove
  it from the requestors list to ensure that we are counting requests correctly and not
  tracking obsolete+enabled requestors.
 */
+ (void)removeRequestorWithId:(id)requestor;

/*!
 @brief This method is called from ViewRootImpl or WallpaperService when either a window is no
  longer visible (enable == false) or when a window becomes visible (enable == true).
 If animators are not properly disabled when activities are backgrounded, it can lead to
  unnecessary processing, particularly for infinite animators, as the system will continue
  to pulse timing events even though the results are not visible. As a workaround, we
  pause all un-paused infinite animators, and resume them when any window in the process
  becomes visible.
 */
+ (void)requestAnimatorsEnabledWithBoolean:(bool)enable
                                    withId:(id)requestor;

/*!
 @brief Disable the default behavior of pausing infinite animators when
  apps go into the background.
 @param enable Enable (default behavior) or disable background pausing behavior.
 */
+ (void)setAnimatorPausingEnabledWithBoolean:(bool)enable;

+ (void)setFrameDelayWithLong:(int64_t)delay;

/*!
 @brief Prevents the setAnimatorPausingEnabled behavior from being overridden
  by the 'framework.pause_bg_animations.enabled' system property value.
 This is for testing purposes only.
 @param enable Enable or disable (default behavior) overriding the system                property.
 */
+ (void)setOverrideAnimatorPausingSystemPropertyWithBoolean:(bool)enable;

/*!
 @brief By default, the Choreographer is used to provide timing for frame callbacks.A custom
  provider can be used here to provide different timing pulse.
 */
- (void)setProviderWithADAnimationHandler_AnimationFrameCallbackProvider:(id<ADAnimationHandler_AnimationFrameCallbackProvider>)provider;

/*!
 @brief Sets an instance that will be returned by <code>getInstance()</code> on every thread.
 @return the previously active test handler, if any.
 */
+ (ADAnimationHandler *)setTestHandlerWithADAnimationHandler:(ADAnimationHandler *)handler;

#pragma mark Package-Private

- (void)autoCancelBasedOnWithADObjectAnimator:(ADObjectAnimator *)objectAnimator;

@end

J2OBJC_STATIC_INIT(ADAnimationHandler)

inline JavaLangThreadLocal *ADAnimationHandler_get_sAnimatorHandler(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaLangThreadLocal *ADAnimationHandler_sAnimatorHandler;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADAnimationHandler, sAnimatorHandler, JavaLangThreadLocal *)

FOUNDATION_EXPORT void ADAnimationHandler_init(ADAnimationHandler *self);

FOUNDATION_EXPORT ADAnimationHandler *new_ADAnimationHandler_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADAnimationHandler *create_ADAnimationHandler_init(void);

FOUNDATION_EXPORT ADAnimationHandler *ADAnimationHandler_getInstance(void);

FOUNDATION_EXPORT ADAnimationHandler *ADAnimationHandler_setTestHandlerWithADAnimationHandler_(ADAnimationHandler *handler);

FOUNDATION_EXPORT void ADAnimationHandler_setAnimatorPausingEnabledWithBoolean_(bool enable);

FOUNDATION_EXPORT void ADAnimationHandler_setOverrideAnimatorPausingSystemPropertyWithBoolean_(bool enable);

FOUNDATION_EXPORT void ADAnimationHandler_removeRequestorWithId_(id requestor);

FOUNDATION_EXPORT void ADAnimationHandler_requestAnimatorsEnabledWithBoolean_withId_(bool enable, id requestor);

FOUNDATION_EXPORT int32_t ADAnimationHandler_getAnimationCount(void);

FOUNDATION_EXPORT void ADAnimationHandler_setFrameDelayWithLong_(int64_t delay);

FOUNDATION_EXPORT int64_t ADAnimationHandler_getFrameDelay(void);

J2OBJC_TYPE_LITERAL_HEADER(ADAnimationHandler)

@compatibility_alias RAndroidAnimationAnimationHandler ADAnimationHandler;


#endif

#if !defined (ADAnimationHandler_AnimationFrameCallbackProvider_) && (INCLUDE_ALL_AnimationHandler || defined(INCLUDE_ADAnimationHandler_AnimationFrameCallbackProvider))
#define ADAnimationHandler_AnimationFrameCallbackProvider_

@class JavaLangLong;
@protocol ADChoreographer_FrameCallback;
@protocol JavaLangRunnable;

/*!
 @brief The intention for having this interface is to increase the testability of ValueAnimator.
 Specifically, we can have a custom implementation of the interface below and provide
  timing pulse without using Choreographer. That way we could use any arbitrary interval for
  our timing pulse in the tests.
 */
@protocol ADAnimationHandler_AnimationFrameCallbackProvider < JavaObject >

- (void)postFrameCallbackWithADChoreographer_FrameCallback:(id<ADChoreographer_FrameCallback>)callback;

- (void)postCommitCallbackWithJavaLangRunnable:(id<JavaLangRunnable>)runnable;

- (int64_t)getFrameTime;

- (int64_t)getFrameDelay;

- (void)setFrameDelayWithLong:(int64_t)delay;

@end

J2OBJC_EMPTY_STATIC_INIT(ADAnimationHandler_AnimationFrameCallbackProvider)

J2OBJC_TYPE_LITERAL_HEADER(ADAnimationHandler_AnimationFrameCallbackProvider)


#endif

#if !defined (ADAnimationHandler_AnimationFrameCallback_) && (INCLUDE_ALL_AnimationHandler || defined(INCLUDE_ADAnimationHandler_AnimationFrameCallback))
#define ADAnimationHandler_AnimationFrameCallback_

@class JavaLangBoolean;
@class JavaLangLong;

/*!
 @brief Callbacks that receives notifications for animation timing and frame commit timing.
 */
@protocol ADAnimationHandler_AnimationFrameCallback < JavaObject >

/*!
 @brief Run animation based on the frame time.
 @param frameTime The frame start time, in the <code>SystemClock.uptimeMillis()</code>  time
                    base.
 @return if the animation has finished.
 */
- (bool)doAnimationFrameWithLong:(int64_t)frameTime;

/*!
 @brief This notifies the callback of frame commit time.Frame commit time is the time after
  traversals happen, as opposed to the normal animation frame time that is before
  traversals.
 This is used to compensate expensive traversals that happen as the
  animation starts. When traversals take a long time to complete, the rendering of the
  initial frame will be delayed (by a long time). But since the startTime of the
  animation is set before the traversal, by the time of next frame, a lot of time would
  have passed since startTime was set, the animation will consequently skip a few frames
  to respect the new frameTime. By having the commit time, we can adjust the start time to
  when the first frame was drawn (after any expensive traversals) so that no frames
  will be skipped.
 @param frameTime The frame time after traversals happen, if any, in the                   
 <code>SystemClock.uptimeMillis()</code>  time base.
 */
- (void)commitAnimationFrameWithLong:(int64_t)frameTime;

@end

J2OBJC_EMPTY_STATIC_INIT(ADAnimationHandler_AnimationFrameCallback)

J2OBJC_TYPE_LITERAL_HEADER(ADAnimationHandler_AnimationFrameCallback)


#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_AnimationHandler")
