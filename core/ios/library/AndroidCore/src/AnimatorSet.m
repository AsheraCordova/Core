//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroid\src\main\java\r\android\animation\AnimatorSet.java
//

#define J2OBJC_IMPORTED_BY_JAVA_IMPLEMENTATION 1




#include "ActivityThread.h"
#include "AndroidRuntimeException.h"
#include "AnimationHandler.h"
#include "Animator.h"
#include "AnimatorListenerAdapter.h"
#include "AnimatorSet.h"
#include "Application.h"
#include "ApplicationInfo.h"
#include "ArrayMap.h"
#include "Build.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "Log.h"
#include "LongArray.h"
#include "Looper.h"
#include "ObjectAnimator.h"
#include "TimeInterpolator.h"
#include "ValueAnimator.h"
#include "java/lang/AssertionError.h"
#include "java/lang/Boolean.h"
#include "java/lang/Character.h"
#include "java/lang/CloneNotSupportedException.h"
#include "java/lang/Float.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/Comparator.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"
#include "java/util/function/Consumer.h"
#include "java/util/function/Function.h"
#include "java/util/function/ToDoubleFunction.h"
#include "java/util/function/ToIntFunction.h"
#include "java/util/function/ToLongFunction.h"


@class ADAnimatorSet_AnimationEvent;
@class ADAnimatorSet_Node;
@class ADAnimatorSet_SeekState;
@class NSString;


#pragma clang diagnostic error "-Wreturn-type"
#pragma clang diagnostic ignored "-Wswitch"


#pragma clang diagnostic ignored "-Wprotocol"

@interface ADAnimatorSet () {
 @public
  /*!
   @brief Tracks animations currently being played, so that we know what to
  cancel or end when cancel() or end() is called on this AnimatorSet
   */
  JavaUtilArrayList *mPlayingSet_;
  /*!
   @brief Contains all nodes, mapped to their respective Animators.When new
  dependency information is added for an Animator, we want to add it
  to a single node representing that Animator, not create a new Node
  if one already exists.
   */
  ADArrayMap *mNodeMap_;
  /*!
   @brief Contains the start and end events of all the nodes.All these events are sorted in this list.
   */
  JavaUtilArrayList *mEvents_;
  /*!
   @brief Set of all nodes created for this AnimatorSet.This list is used upon
  starting the set, and the nodes are placed in sorted order into the
  sortedNodes collection.
   */
  JavaUtilArrayList *mNodes_;
  /*!
   @brief Tracks whether any change has been made to the AnimatorSet, which is then used to
  determine whether the dependency graph should be re-constructed.
   */
  bool mDependencyDirty_;
  /*!
   @brief Indicates whether an AnimatorSet has been start()'d, whether or
  not there is a nonzero startDelay.
   */
  bool mStarted_;
  int64_t mStartDelay_;
  ADValueAnimator *mDelayAnim_;
  ADAnimatorSet_Node *mRootNode_;
  int64_t mDuration_;
  id<ADTimeInterpolator> mInterpolator_;
  int64_t mTotalDuration_;
  bool mShouldIgnoreEndWithoutStart_;
  bool mShouldResetValuesAtStart_;
  bool mEndCanBeCalled_;
  int64_t mLastFrameTime_;
  int64_t mFirstFrame_;
  int32_t mLastEventId_;
  bool mReversing_;
  bool mSelfPulse_;
  ADAnimatorSet_SeekState *mSeekState_;
  bool mChildrenInitialized_;
  /*!
   @brief Set on the next frame after pause() is called, used to calculate a new startTime
  or delayStartTime which allows the animator set to continue from the point at which
  it was paused.If negative, has not yet been set.
   */
  int64_t mPauseTime_;
  /*!
   @brief The start and stop times of all descendant animators.
   */
  IOSLongArray *mChildStartAndStopTimes_;
  ADAnimatorListenerAdapter *mAnimationEndListener_;
}

/*!
 @brief Calls consumer on every Animator of mPlayingSet.
 @param consumer The method to call on every Animator of mPlayingSet.
 */
- (void)callOnPlayingSetWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)consumer;

- (void)forceToEnd;

- (void)initAnimation OBJC_METHOD_FAMILY_NONE;

- (void)startWithBoolean:(bool)inReverse
             withBoolean:(bool)selfPulse;

+ (bool)isEmptySetWithADAnimatorSet:(ADAnimatorSet *)set;

- (void)updateAnimatorsDuration;

/*!
 @brief Internal only.
 This method sets the animation values based on the play time. It also fast forward or
  backward all the child animations progress accordingly.
  This method is also responsible for calling 
 <code>r.android.view.animation.Animation.AnimationListener.onAnimationRepeat(Animation)</code>,
  as needed, based on the last play time and current play time.
 */
- (void)animateBasedOnPlayTimeWithLong:(int64_t)currentPlayTime
                              withLong:(int64_t)lastPlayTime
                           withBoolean:(bool)inReverse;

/*!
 @brief Looks through startEndTimes for playTime.If it is in startEndTimes, the index after
  is returned.
 Otherwise, it returns the index at which it would be placed if it were
  to be inserted.
 */
- (int32_t)findNextIndexWithLong:(int64_t)playTime
                   withLongArray:(IOSLongArray *)startEndTimes;

- (IOSLongArray *)ensureChildStartAndEndTimes;

- (void)initChildren OBJC_METHOD_FAMILY_NONE;

/*!
 @brief When playing forward, we call start() at the animation's scheduled start time, and make sure
  to pump a frame at the animation's scheduled end time.
 When playing in reverse, we should reverse the animation when we hit animation's end event,
  and expect the animation to end at the its delay ended event, rather than start event.
 */
- (void)handleAnimationEventsWithInt:(int32_t)startId
                             withInt:(int32_t)latestId
                            withLong:(int64_t)playTime;

/*!
 @brief This method pulses frames into child animations.It scales the input animation play time
  with the duration scale and pass that to the child animation via pulseAnimationFrame(long).
 @param node child animator node
 @param animPlayTime unscaled play time (including start delay) for the child animator
 */
- (void)pulseFrameWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node
                                withLong:(int64_t)animPlayTime;

- (int64_t)getPlayTimeForNodeIncludingDelayWithLong:(int64_t)overallPlayTime
                             withADAnimatorSet_Node:(ADAnimatorSet_Node *)node;

- (int64_t)getPlayTimeForNodeIncludingDelayWithLong:(int64_t)overallPlayTime
                             withADAnimatorSet_Node:(ADAnimatorSet_Node *)node
                                        withBoolean:(bool)inReverse;

- (void)startAnimation;

- (void)addAnimationEndListener;

- (void)removeAnimationEndListener;

- (int32_t)findLatestEventIdForTimeWithLong:(int64_t)currentPlayTime;

- (void)endAnimation;

- (void)removeAnimationCallback;

- (void)addAnimationCallbackWithLong:(int64_t)delay;

- (void)printChildCount;

- (void)createDependencyGraph;

- (void)sortAnimationEvents;

/*!
 @brief Based on parent's start/end time, calculate children's start/end time.If cycle exists in
  the graph, all the nodes on the cycle will be marked to start at <code>DURATION_INFINITE</code>,
  meaning they will ever play.
 */
- (void)updatePlayTimeWithADAnimatorSet_Node:(ADAnimatorSet_Node *)parent
                       withJavaUtilArrayList:(JavaUtilArrayList *)visited;

- (void)findSiblingsWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node
                     withJavaUtilArrayList:(JavaUtilArrayList *)siblings;

- (ADAnimatorSet_Node *)getNodeForAnimationWithADAnimator:(ADAnimator *)anim;

@end

J2OBJC_FIELD_SETTER(ADAnimatorSet, mPlayingSet_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADAnimatorSet, mNodeMap_, ADArrayMap *)
J2OBJC_FIELD_SETTER(ADAnimatorSet, mEvents_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADAnimatorSet, mNodes_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADAnimatorSet, mDelayAnim_, ADValueAnimator *)
J2OBJC_FIELD_SETTER(ADAnimatorSet, mRootNode_, ADAnimatorSet_Node *)
J2OBJC_FIELD_SETTER(ADAnimatorSet, mInterpolator_, id<ADTimeInterpolator>)
J2OBJC_FIELD_SETTER(ADAnimatorSet, mSeekState_, ADAnimatorSet_SeekState *)
J2OBJC_FIELD_SETTER(ADAnimatorSet, mChildStartAndStopTimes_, IOSLongArray *)
J2OBJC_FIELD_SETTER(ADAnimatorSet, mAnimationEndListener_, ADAnimatorListenerAdapter *)

inline NSString *ADAnimatorSet_get_TAG(void);
static NSString *ADAnimatorSet_TAG = @"AnimatorSet";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADAnimatorSet, TAG, NSString *)

__attribute__((unused)) static void ADAnimatorSet_callOnPlayingSetWithJavaUtilFunctionConsumer_(ADAnimatorSet *self, id<JavaUtilFunctionConsumer> consumer);

__attribute__((unused)) static void ADAnimatorSet_forceToEnd(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_initAnimation(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_startWithBoolean_withBoolean_(ADAnimatorSet *self, bool inReverse, bool selfPulse);

__attribute__((unused)) static bool ADAnimatorSet_isEmptySetWithADAnimatorSet_(ADAnimatorSet *set);

__attribute__((unused)) static void ADAnimatorSet_updateAnimatorsDuration(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_animateBasedOnPlayTimeWithLong_withLong_withBoolean_(ADAnimatorSet *self, int64_t currentPlayTime, int64_t lastPlayTime, bool inReverse);

__attribute__((unused)) static int32_t ADAnimatorSet_findNextIndexWithLong_withLongArray_(ADAnimatorSet *self, int64_t playTime, IOSLongArray *startEndTimes);

__attribute__((unused)) static IOSLongArray *ADAnimatorSet_ensureChildStartAndEndTimes(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_initChildren(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_handleAnimationEventsWithInt_withInt_withLong_(ADAnimatorSet *self, int32_t startId, int32_t latestId, int64_t playTime);

__attribute__((unused)) static void ADAnimatorSet_pulseFrameWithADAnimatorSet_Node_withLong_(ADAnimatorSet *self, ADAnimatorSet_Node *node, int64_t animPlayTime);

__attribute__((unused)) static int64_t ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_(ADAnimatorSet *self, int64_t overallPlayTime, ADAnimatorSet_Node *node);

__attribute__((unused)) static int64_t ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_withBoolean_(ADAnimatorSet *self, int64_t overallPlayTime, ADAnimatorSet_Node *node, bool inReverse);

__attribute__((unused)) static void ADAnimatorSet_startAnimation(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_addAnimationEndListener(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_removeAnimationEndListener(ADAnimatorSet *self);

__attribute__((unused)) static int32_t ADAnimatorSet_findLatestEventIdForTimeWithLong_(ADAnimatorSet *self, int64_t currentPlayTime);

__attribute__((unused)) static void ADAnimatorSet_endAnimation(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_removeAnimationCallback(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_addAnimationCallbackWithLong_(ADAnimatorSet *self, int64_t delay);

__attribute__((unused)) static void ADAnimatorSet_printChildCount(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_createDependencyGraph(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_sortAnimationEvents(ADAnimatorSet *self);

__attribute__((unused)) static void ADAnimatorSet_updatePlayTimeWithADAnimatorSet_Node_withJavaUtilArrayList_(ADAnimatorSet *self, ADAnimatorSet_Node *parent, JavaUtilArrayList *visited);

__attribute__((unused)) static void ADAnimatorSet_findSiblingsWithADAnimatorSet_Node_withJavaUtilArrayList_(ADAnimatorSet *self, ADAnimatorSet_Node *node, JavaUtilArrayList *siblings);

__attribute__((unused)) static ADAnimatorSet_Node *ADAnimatorSet_getNodeForAnimationWithADAnimator_(ADAnimatorSet *self, ADAnimator *anim);

@interface ADAnimatorSet_1 : ADAnimatorListenerAdapter {
 @public
  ADAnimatorSet *this$0_;
}

- (instancetype)initWithADAnimatorSet:(ADAnimatorSet *)outer$;

- (void)onAnimationEndWithADAnimator:(ADAnimator *)animation;

@end

J2OBJC_EMPTY_STATIC_INIT(ADAnimatorSet_1)

__attribute__((unused)) static void ADAnimatorSet_1_initWithADAnimatorSet_(ADAnimatorSet_1 *self, ADAnimatorSet *outer$);

__attribute__((unused)) static ADAnimatorSet_1 *new_ADAnimatorSet_1_initWithADAnimatorSet_(ADAnimatorSet *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADAnimatorSet_1 *create_ADAnimatorSet_1_initWithADAnimatorSet_(ADAnimatorSet *outer$);


@interface ADAnimatorSet_2 : ADAnimatorListenerAdapter {
 @public
  ADAnimatorSet *val$anim_;
}

- (instancetype)initWithADAnimatorSet:(ADAnimatorSet *)capture$0;

- (void)onAnimationEndWithADAnimator:(ADAnimator *)animation;

@end

J2OBJC_EMPTY_STATIC_INIT(ADAnimatorSet_2)

__attribute__((unused)) static void ADAnimatorSet_2_initWithADAnimatorSet_(ADAnimatorSet_2 *self, ADAnimatorSet *capture$0);

__attribute__((unused)) static ADAnimatorSet_2 *new_ADAnimatorSet_2_initWithADAnimatorSet_(ADAnimatorSet *capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADAnimatorSet_2 *create_ADAnimatorSet_2_initWithADAnimatorSet_(ADAnimatorSet *capture$0);


@interface ADAnimatorSet_3 : NSObject < JavaUtilComparator >

- (instancetype)init;

- (int32_t)compareWithId:(ADAnimatorSet_AnimationEvent *)e1
                  withId:(ADAnimatorSet_AnimationEvent *)e2;

@end

J2OBJC_EMPTY_STATIC_INIT(ADAnimatorSet_3)

__attribute__((unused)) static void ADAnimatorSet_3_init(ADAnimatorSet_3 *self);

__attribute__((unused)) static ADAnimatorSet_3 *new_ADAnimatorSet_3_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADAnimatorSet_3 *create_ADAnimatorSet_3_init(void);


/*!
 @brief A Node is an embodiment of both the Animator that it wraps as well as
  any dependencies that are associated with that Animation.This includes
  both dependencies upon other nodes (in the dependencies list) as
  well as dependencies of other nodes upon this (in the nodeDependents list).
 */
@interface ADAnimatorSet_Node : NSObject < NSCopying > {
 @public
  ADAnimator *mAnimation_;
  /*!
   @brief Child nodes are the nodes associated with animations that will be played immediately
  after current node.
   */
  JavaUtilArrayList *mChildNodes_;
  /*!
   @brief Flag indicating whether the animation in this node is finished.This flag
  is used by AnimatorSet to check, as each animation ends, whether all child animations
  are mEnded and it's time to send out an end event for the entire AnimatorSet.
   */
  bool mEnded_;
  /*!
   @brief Nodes with animations that are defined to play simultaneously with the animation
  associated with this current node.
   */
  JavaUtilArrayList *mSiblings_;
  /*!
   @brief Parent nodes are the nodes with animations preceding current node's animation.Parent
  nodes here are derived from user defined animation sequence.
   */
  JavaUtilArrayList *mParents_;
  /*!
   @brief Latest parent is the parent node associated with a animation that finishes after all
  the other parents' animations.
   */
  ADAnimatorSet_Node *mLatestParent_;
  bool mParentsAdded_;
  int64_t mStartTime_;
  int64_t mEndTime_;
  int64_t mTotalDuration_;
}

/*!
 @brief Constructs the Node with the animation that it encapsulates.A Node has no
  dependencies by default; dependencies are added via the addDependency()
  method.
 @param animation The animation that the Node encapsulates.
 */
- (instancetype)initWithADAnimator:(ADAnimator *)animation;

- (ADAnimatorSet_Node *)java_clone;

- (void)addChildWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node;

- (void)addSiblingWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node;

- (void)addParentWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node;

- (void)addParentsWithJavaUtilArrayList:(JavaUtilArrayList *)parents;

@end

J2OBJC_EMPTY_STATIC_INIT(ADAnimatorSet_Node)

J2OBJC_FIELD_SETTER(ADAnimatorSet_Node, mAnimation_, ADAnimator *)
J2OBJC_FIELD_SETTER(ADAnimatorSet_Node, mChildNodes_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADAnimatorSet_Node, mSiblings_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADAnimatorSet_Node, mParents_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ADAnimatorSet_Node, mLatestParent_, ADAnimatorSet_Node *)

__attribute__((unused)) static void ADAnimatorSet_Node_initWithADAnimator_(ADAnimatorSet_Node *self, ADAnimator *animation);

__attribute__((unused)) static ADAnimatorSet_Node *new_ADAnimatorSet_Node_initWithADAnimator_(ADAnimator *animation) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADAnimatorSet_Node *create_ADAnimatorSet_Node_initWithADAnimator_(ADAnimator *animation);

J2OBJC_TYPE_LITERAL_HEADER(ADAnimatorSet_Node)


/*!
 @brief This class is a wrapper around a node and an event for the animation corresponding to the
  node.The 3 types of events represent the start of an animation, the end of a start delay of
  an animation, and the end of an animation.
 When playing forward (i.e. in the non-reverse
  direction), start event marks when start() should be called, and end event corresponds to
  when the animation should finish. When playing in reverse, start delay will not be a part
  of the animation. Therefore, reverse() is called at the end event, and animation should end
  at the delay ended event.
 */
@interface ADAnimatorSet_AnimationEvent : NSObject {
 @public
  ADAnimatorSet_Node *mNode_;
  int32_t mEvent_;
}

- (instancetype)initWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node
                                   withInt:(int32_t)event;

- (int64_t)getTime;

- (NSString *)description;

@end

J2OBJC_EMPTY_STATIC_INIT(ADAnimatorSet_AnimationEvent)

J2OBJC_FIELD_SETTER(ADAnimatorSet_AnimationEvent, mNode_, ADAnimatorSet_Node *)

inline int32_t ADAnimatorSet_AnimationEvent_get_ANIMATION_START(void);
#define ADAnimatorSet_AnimationEvent_ANIMATION_START 0
J2OBJC_STATIC_FIELD_CONSTANT(ADAnimatorSet_AnimationEvent, ANIMATION_START, int32_t)

inline int32_t ADAnimatorSet_AnimationEvent_get_ANIMATION_DELAY_ENDED(void);
#define ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED 1
J2OBJC_STATIC_FIELD_CONSTANT(ADAnimatorSet_AnimationEvent, ANIMATION_DELAY_ENDED, int32_t)

inline int32_t ADAnimatorSet_AnimationEvent_get_ANIMATION_END(void);
#define ADAnimatorSet_AnimationEvent_ANIMATION_END 2
J2OBJC_STATIC_FIELD_CONSTANT(ADAnimatorSet_AnimationEvent, ANIMATION_END, int32_t)

__attribute__((unused)) static void ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(ADAnimatorSet_AnimationEvent *self, ADAnimatorSet_Node *node, int32_t event);

__attribute__((unused)) static ADAnimatorSet_AnimationEvent *new_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(ADAnimatorSet_Node *node, int32_t event) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADAnimatorSet_AnimationEvent *create_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(ADAnimatorSet_Node *node, int32_t event);

J2OBJC_TYPE_LITERAL_HEADER(ADAnimatorSet_AnimationEvent)


@interface ADAnimatorSet_SeekState : NSObject {
 @public
  ADAnimatorSet *this$0_;
  int64_t mPlayTime_;
  bool mSeekingInReverse_;
}

- (instancetype)initWithADAnimatorSet:(ADAnimatorSet *)outer$;

- (void)reset;

- (void)setPlayTimeWithLong:(int64_t)playTime
                withBoolean:(bool)inReverse;

- (void)updateSeekDirectionWithBoolean:(bool)inReverse;

- (int64_t)getPlayTime;

/*!
 @brief Returns the playtime assuming the animation is forward playing
 */
- (int64_t)getPlayTimeNormalized;

- (bool)isActive;

@end

J2OBJC_EMPTY_STATIC_INIT(ADAnimatorSet_SeekState)

__attribute__((unused)) static void ADAnimatorSet_SeekState_initWithADAnimatorSet_(ADAnimatorSet_SeekState *self, ADAnimatorSet *outer$);

__attribute__((unused)) static ADAnimatorSet_SeekState *new_ADAnimatorSet_SeekState_initWithADAnimatorSet_(ADAnimatorSet *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADAnimatorSet_SeekState *create_ADAnimatorSet_SeekState_initWithADAnimatorSet_(ADAnimatorSet *outer$);

J2OBJC_TYPE_LITERAL_HEADER(ADAnimatorSet_SeekState)


@interface ADAnimatorSet_Builder () {
 @public
  ADAnimatorSet *this$0_;
  /*!
   @brief This tracks the current node being processed.It is supplied to the play() method
  of AnimatorSet and passed into the constructor of Builder.
   */
  ADAnimatorSet_Node *mCurrentNode_;
}

@end

J2OBJC_FIELD_SETTER(ADAnimatorSet_Builder, mCurrentNode_, ADAnimatorSet_Node *)

@interface ADAnimatorSet_$Lambda$1 : NSObject < JavaUtilFunctionConsumer >

- (void)acceptWithId:(ADAnimator *)a;

@end

J2OBJC_STATIC_INIT(ADAnimatorSet_$Lambda$1)

inline ADAnimatorSet_$Lambda$1 *ADAnimatorSet_$Lambda$1_get_instance(void);
static ADAnimatorSet_$Lambda$1 *ADAnimatorSet_$Lambda$1_instance;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADAnimatorSet_$Lambda$1, instance, ADAnimatorSet_$Lambda$1 *)

__attribute__((unused)) static void ADAnimatorSet_$Lambda$1_init(ADAnimatorSet_$Lambda$1 *self);

__attribute__((unused)) static ADAnimatorSet_$Lambda$1 *new_ADAnimatorSet_$Lambda$1_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADAnimatorSet_$Lambda$1 *create_ADAnimatorSet_$Lambda$1_init(void);


@interface ADAnimatorSet_$Lambda$2 : NSObject < JavaUtilFunctionConsumer >

- (void)acceptWithId:(ADAnimator *)a;

@end

J2OBJC_STATIC_INIT(ADAnimatorSet_$Lambda$2)

inline ADAnimatorSet_$Lambda$2 *ADAnimatorSet_$Lambda$2_get_instance(void);
static ADAnimatorSet_$Lambda$2 *ADAnimatorSet_$Lambda$2_instance;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADAnimatorSet_$Lambda$2, instance, ADAnimatorSet_$Lambda$2 *)

__attribute__((unused)) static void ADAnimatorSet_$Lambda$2_init(ADAnimatorSet_$Lambda$2 *self);

__attribute__((unused)) static ADAnimatorSet_$Lambda$2 *new_ADAnimatorSet_$Lambda$2_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADAnimatorSet_$Lambda$2 *create_ADAnimatorSet_$Lambda$2_init(void);


@interface ADAnimatorSet_$Lambda$3 : NSObject < JavaUtilFunctionConsumer >

- (void)acceptWithId:(ADAnimator *)a;

@end

J2OBJC_STATIC_INIT(ADAnimatorSet_$Lambda$3)

inline ADAnimatorSet_$Lambda$3 *ADAnimatorSet_$Lambda$3_get_instance(void);
static ADAnimatorSet_$Lambda$3 *ADAnimatorSet_$Lambda$3_instance;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADAnimatorSet_$Lambda$3, instance, ADAnimatorSet_$Lambda$3 *)

__attribute__((unused)) static void ADAnimatorSet_$Lambda$3_init(ADAnimatorSet_$Lambda$3 *self);

__attribute__((unused)) static ADAnimatorSet_$Lambda$3 *new_ADAnimatorSet_$Lambda$3_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static ADAnimatorSet_$Lambda$3 *create_ADAnimatorSet_$Lambda$3_init(void);


@implementation ADAnimatorSet

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADAnimatorSet_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)playTogetherWithADAnimatorArray:(IOSObjectArray *)items {
  if (items != nil) {
    ADAnimatorSet_Builder *builder = JreRetainedLocalValue([self playWithADAnimator:IOSObjectArray_Get(items, 0)]);
    for (int32_t i = 1; i < items->size_; ++i) {
      [((ADAnimatorSet_Builder *) nil_chk(builder)) withWithADAnimator:IOSObjectArray_Get(items, i)];
    }
  }
}

- (void)playTogetherWithJavaUtilCollection:(id<JavaUtilCollection>)items {
  if (items != nil && [items size] > 0) {
    ADAnimatorSet_Builder *builder = nil;
    for (ADAnimator * __strong anim in items) {
      if (builder == nil) {
        builder = [self playWithADAnimator:anim];
      }
      else {
        [builder withWithADAnimator:anim];
      }
    }
  }
}

- (void)playSequentiallyWithADAnimatorArray:(IOSObjectArray *)items {
  if (items != nil) {
    if (items->size_ == 1) {
      [self playWithADAnimator:IOSObjectArray_Get(items, 0)];
    }
    else {
      for (int32_t i = 0; i < items->size_ - 1; ++i) {
        [((ADAnimatorSet_Builder *) nil_chk([self playWithADAnimator:IOSObjectArray_Get(items, i)])) beforeWithADAnimator:IOSObjectArray_Get(items, i + 1)];
      }
    }
  }
}

- (void)playSequentiallyWithJavaUtilList:(id<JavaUtilList>)items {
  if (items != nil && [items size] > 0) {
    if ([items size] == 1) {
      [self playWithADAnimator:[items getWithInt:0]];
    }
    else {
      for (int32_t i = 0; i < [items size] - 1; ++i) {
        [((ADAnimatorSet_Builder *) nil_chk([self playWithADAnimator:[items getWithInt:i]])) beforeWithADAnimator:[items getWithInt:i + 1]];
      }
    }
  }
}

- (JavaUtilArrayList *)getChildAnimations {
  JavaUtilArrayList *childList = create_JavaUtilArrayList_init();
  int32_t size = [((JavaUtilArrayList *) nil_chk(mNodes_)) size];
  for (int32_t i = 0; i < size; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:i]);
    if (!JreObjectEqualsEquals(node, mRootNode_)) {
      [childList addWithId:((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_];
    }
  }
  return childList;
}

- (void)setTargetWithId:(id)target {
  int32_t size = [((JavaUtilArrayList *) nil_chk(mNodes_)) size];
  for (int32_t i = 0; i < size; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:i]);
    ADAnimator *animation = JreRetainedLocalValue(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_);
    if ([animation isKindOfClass:[ADAnimatorSet class]]) {
      [((ADAnimatorSet *) nil_chk(((ADAnimatorSet *) animation))) setTargetWithId:target];
    }
    else if ([animation isKindOfClass:[ADObjectAnimator class]]) {
      [((ADObjectAnimator *) nil_chk(((ADObjectAnimator *) animation))) setTargetWithId:target];
    }
  }
}

- (int32_t)getChangingConfigurations {
  int32_t conf = [super getChangingConfigurations];
  int32_t nodeCount = [((JavaUtilArrayList *) nil_chk(mNodes_)) size];
  for (int32_t i = 0; i < nodeCount; i++) {
    conf |= [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:i]))->mAnimation_)) getChangingConfigurations];
  }
  return conf;
}

- (void)setInterpolatorWithADTimeInterpolator:(id<ADTimeInterpolator>)interpolator {
  JreStrongAssign(&mInterpolator_, interpolator);
}

- (id<ADTimeInterpolator>)getInterpolator {
  return mInterpolator_;
}

- (ADAnimatorSet_Builder *)playWithADAnimator:(ADAnimator *)anim {
  if (anim != nil) {
    return create_ADAnimatorSet_Builder_initWithADAnimatorSet_withADAnimator_(self, anim);
  }
  return nil;
}

- (void)cancel {
  if (ADLooper_myLooper() == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Animators may only be run on Looper threads");
  }
  if ([self isStarted] || mStartListenersCalled_) {
    [self notifyListenersWithADAnimator_AnimatorCaller:JreLoadStatic(ADAnimator_AnimatorCaller, ON_CANCEL) withBoolean:false];
    ADAnimatorSet_callOnPlayingSetWithJavaUtilFunctionConsumer_(self, JreLoadStatic(ADAnimatorSet_$Lambda$1, instance));
    [((JavaUtilArrayList *) nil_chk(mPlayingSet_)) clear];
    ADAnimatorSet_endAnimation(self);
  }
}

- (void)callOnPlayingSetWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)consumer {
  ADAnimatorSet_callOnPlayingSetWithJavaUtilFunctionConsumer_(self, consumer);
}

- (void)forceToEnd {
  ADAnimatorSet_forceToEnd(self);
}

- (void)end {
  if (ADLooper_myLooper() == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Animators may only be run on Looper threads");
  }
  if (mShouldIgnoreEndWithoutStart_ && ![self isStarted]) {
    return;
  }
  if ([self isStarted]) {
    mStarted_ = false;
    if (mReversing_) {
      mLastEventId_ = mLastEventId_ == -1 ? [((JavaUtilArrayList *) nil_chk(mEvents_)) size] : mLastEventId_;
      for (int32_t eventId = mLastEventId_ - 1; eventId >= 0; eventId--) {
        ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mEvents_)) getWithInt:eventId]);
        ADAnimator *anim = JreRetainedLocalValue(((ADAnimatorSet_Node *) nil_chk(((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mNode_))->mAnimation_);
        if (((ADAnimatorSet_Node *) nil_chk([((ADArrayMap *) nil_chk(mNodeMap_)) getWithId:anim]))->mEnded_) {
          continue;
        }
        if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_END) {
          [((ADAnimator *) nil_chk(anim)) reverse];
        }
        else if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED && [((ADAnimator *) nil_chk(anim)) isStarted]) {
          [((ADAnimator *) nil_chk(anim)) end];
        }
      }
    }
    else {
      for (int32_t eventId = mLastEventId_ + 1; eventId < [((JavaUtilArrayList *) nil_chk(mEvents_)) size]; eventId++) {
        ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mEvents_)) getWithInt:eventId]);
        ADAnimator *anim = JreRetainedLocalValue(((ADAnimatorSet_Node *) nil_chk(((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mNode_))->mAnimation_);
        if (((ADAnimatorSet_Node *) nil_chk([((ADArrayMap *) nil_chk(mNodeMap_)) getWithId:anim]))->mEnded_) {
          continue;
        }
        if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_START) {
          [((ADAnimator *) nil_chk(anim)) start];
        }
        else if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_END && [((ADAnimator *) nil_chk(anim)) isStarted]) {
          [((ADAnimator *) nil_chk(anim)) end];
        }
      }
    }
  }
  ADAnimatorSet_endAnimation(self);
}

- (bool)isRunning {
  if (mStartDelay_ == 0) {
    return mStarted_;
  }
  return mLastFrameTime_ > 0;
}

- (bool)isStarted {
  return mStarted_;
}

- (int64_t)getStartDelay {
  return mStartDelay_;
}

- (void)setStartDelayWithLong:(int64_t)startDelay {
  if (startDelay < 0) {
    ADLog_wWithNSString_withNSString_(ADAnimatorSet_TAG, @"Start delay should always be non-negative");
    startDelay = 0;
  }
  int64_t delta = startDelay - mStartDelay_;
  if (delta == 0) {
    return;
  }
  mStartDelay_ = startDelay;
  if (!mDependencyDirty_) {
    int32_t size = [((JavaUtilArrayList *) nil_chk(mNodes_)) size];
    for (int32_t i = 0; i < size; i++) {
      ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:i]);
      if (JreObjectEqualsEquals(node, mRootNode_)) {
        ((ADAnimatorSet_Node *) nil_chk(node))->mEndTime_ = mStartDelay_;
      }
      else {
        ((ADAnimatorSet_Node *) nil_chk(node))->mStartTime_ = node->mStartTime_ == ADAnimator_DURATION_INFINITE ? ADAnimator_DURATION_INFINITE : node->mStartTime_ + delta;
        node->mEndTime_ = node->mEndTime_ == ADAnimator_DURATION_INFINITE ? ADAnimator_DURATION_INFINITE : node->mEndTime_ + delta;
      }
    }
    if (mTotalDuration_ != ADAnimator_DURATION_INFINITE) {
      mTotalDuration_ += delta;
    }
  }
}

- (int64_t)getDuration {
  return mDuration_;
}

- (ADAnimatorSet *)setDurationWithLong:(int64_t)duration {
  if (duration < 0) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"duration must be a value of zero or greater");
  }
  mDependencyDirty_ = true;
  mDuration_ = duration;
  return self;
}

- (void)setupStartValues {
  int32_t size = [((JavaUtilArrayList *) nil_chk(mNodes_)) size];
  for (int32_t i = 0; i < size; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:i]);
    if (!JreObjectEqualsEquals(node, mRootNode_)) {
      [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_)) setupStartValues];
    }
  }
}

- (void)setupEndValues {
  int32_t size = [((JavaUtilArrayList *) nil_chk(mNodes_)) size];
  for (int32_t i = 0; i < size; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:i]);
    if (!JreObjectEqualsEquals(node, mRootNode_)) {
      [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_)) setupEndValues];
    }
  }
}

- (void)pause {
  if (ADLooper_myLooper() == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Animators may only be run on Looper threads");
  }
  bool previouslyPaused = mPaused_;
  [super pause];
  if (!previouslyPaused && mPaused_) {
    mPauseTime_ = -1;
    ADAnimatorSet_callOnPlayingSetWithJavaUtilFunctionConsumer_(self, JreLoadStatic(ADAnimatorSet_$Lambda$2, instance));
  }
}

- (void)resume {
  if (ADLooper_myLooper() == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Animators may only be run on Looper threads");
  }
  bool previouslyPaused = mPaused_;
  [super resume];
  if (previouslyPaused && !mPaused_) {
    if (mPauseTime_ >= 0) {
      ADAnimatorSet_addAnimationCallbackWithLong_(self, 0);
    }
    ADAnimatorSet_callOnPlayingSetWithJavaUtilFunctionConsumer_(self, JreLoadStatic(ADAnimatorSet_$Lambda$3, instance));
  }
}

- (void)start {
  ADAnimatorSet_startWithBoolean_withBoolean_(self, false, true);
}

- (void)startWithoutPulsingWithBoolean:(bool)inReverse {
  ADAnimatorSet_startWithBoolean_withBoolean_(self, inReverse, false);
}

- (void)initAnimation {
  ADAnimatorSet_initAnimation(self);
}

- (void)startWithBoolean:(bool)inReverse
             withBoolean:(bool)selfPulse {
  ADAnimatorSet_startWithBoolean_withBoolean_(self, inReverse, selfPulse);
}

+ (bool)isEmptySetWithADAnimatorSet:(ADAnimatorSet *)set {
  return ADAnimatorSet_isEmptySetWithADAnimatorSet_(set);
}

- (void)updateAnimatorsDuration {
  ADAnimatorSet_updateAnimatorsDuration(self);
}

- (void)skipToEndValueWithBoolean:(bool)inReverse {
  ADAnimatorSet_initAnimation(self);
  ADAnimatorSet_initChildren(self);
  if (inReverse) {
    for (int32_t i = [((JavaUtilArrayList *) nil_chk(mEvents_)) size] - 1; i >= 0; i--) {
      ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mEvents_)) getWithInt:i]);
      if (((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED) {
        [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(event->mNode_))->mAnimation_)) skipToEndValueWithBoolean:true];
      }
    }
  }
  else {
    for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk(mEvents_)) size]; i++) {
      ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mEvents_)) getWithInt:i]);
      if (((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_END) {
        [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(event->mNode_))->mAnimation_)) skipToEndValueWithBoolean:false];
      }
    }
  }
}

- (void)animateBasedOnPlayTimeWithLong:(int64_t)currentPlayTime
                              withLong:(int64_t)lastPlayTime
                           withBoolean:(bool)inReverse {
  ADAnimatorSet_animateBasedOnPlayTimeWithLong_withLong_withBoolean_(self, currentPlayTime, lastPlayTime, inReverse);
}

- (int32_t)findNextIndexWithLong:(int64_t)playTime
                   withLongArray:(IOSLongArray *)startEndTimes {
  return ADAnimatorSet_findNextIndexWithLong_withLongArray_(self, playTime, startEndTimes);
}

- (void)animateSkipToEndsWithLong:(int64_t)currentPlayTime
                         withLong:(int64_t)lastPlayTime {
  ADAnimatorSet_initAnimation(self);
  if (lastPlayTime > currentPlayTime) {
    [self notifyStartListenersWithBoolean:true];
    for (int32_t i = [((JavaUtilArrayList *) nil_chk(mEvents_)) size] - 1; i >= 0; i--) {
      ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mEvents_)) getWithInt:i]);
      ADAnimatorSet_Node *node = JreRetainedLocalValue(((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mNode_);
      if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_END && ((ADAnimatorSet_Node *) nil_chk(node))->mStartTime_ != ADAnimator_DURATION_INFINITE) {
        ADAnimator *animator = JreRetainedLocalValue(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_);
        int64_t start = node->mStartTime_;
        int64_t end = node->mTotalDuration_ == ADAnimator_DURATION_INFINITE ? JavaLangLong_MAX_VALUE : node->mEndTime_;
        if (currentPlayTime <= start && start < lastPlayTime) {
          [((ADAnimator *) nil_chk(animator)) animateSkipToEndsWithLong:0 withLong:lastPlayTime - node->mStartTime_];
          [((JavaUtilArrayList *) nil_chk(mPlayingSet_)) removeWithId:node];
        }
        else if (start <= currentPlayTime && currentPlayTime <= end) {
          [((ADAnimator *) nil_chk(animator)) animateSkipToEndsWithLong:currentPlayTime - node->mStartTime_ withLong:lastPlayTime - node->mStartTime_];
          if (![((JavaUtilArrayList *) nil_chk(mPlayingSet_)) containsWithId:node]) {
            [((JavaUtilArrayList *) nil_chk(mPlayingSet_)) addWithId:node];
          }
        }
      }
    }
    if (currentPlayTime <= 0) {
      [self notifyEndListenersWithBoolean:true];
    }
  }
  else {
    [self notifyStartListenersWithBoolean:false];
    int32_t eventsSize = [((JavaUtilArrayList *) nil_chk(mEvents_)) size];
    for (int32_t i = 0; i < eventsSize; i++) {
      ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mEvents_)) getWithInt:i]);
      ADAnimatorSet_Node *node = JreRetainedLocalValue(((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mNode_);
      if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED && ((ADAnimatorSet_Node *) nil_chk(node))->mStartTime_ != ADAnimator_DURATION_INFINITE) {
        ADAnimator *animator = JreRetainedLocalValue(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_);
        int64_t start = node->mStartTime_;
        int64_t end = node->mTotalDuration_ == ADAnimator_DURATION_INFINITE ? JavaLangLong_MAX_VALUE : node->mEndTime_;
        if (lastPlayTime < end && end <= currentPlayTime) {
          [((ADAnimator *) nil_chk(animator)) animateSkipToEndsWithLong:end - node->mStartTime_ withLong:lastPlayTime - node->mStartTime_];
          [((JavaUtilArrayList *) nil_chk(mPlayingSet_)) removeWithId:node];
        }
        else if (start <= currentPlayTime && currentPlayTime <= end) {
          [((ADAnimator *) nil_chk(animator)) animateSkipToEndsWithLong:currentPlayTime - node->mStartTime_ withLong:lastPlayTime - node->mStartTime_];
          if (![((JavaUtilArrayList *) nil_chk(mPlayingSet_)) containsWithId:node]) {
            [((JavaUtilArrayList *) nil_chk(mPlayingSet_)) addWithId:node];
          }
        }
      }
    }
    if (currentPlayTime >= [self getTotalDuration]) {
      [self notifyEndListenersWithBoolean:false];
    }
  }
}

- (void)animateValuesInRangeWithLong:(int64_t)currentPlayTime
                            withLong:(int64_t)lastPlayTime {
  ADAnimatorSet_initAnimation(self);
  if (lastPlayTime < 0 || (lastPlayTime == 0 && currentPlayTime > 0)) {
    [self notifyStartListenersWithBoolean:false];
  }
  else {
    int64_t duration = [self getTotalDuration];
    if (duration >= 0 && (lastPlayTime > duration || (lastPlayTime == duration && currentPlayTime < duration))) {
      [self notifyStartListenersWithBoolean:true];
    }
  }
  int32_t eventsSize = [((JavaUtilArrayList *) nil_chk(mEvents_)) size];
  for (int32_t i = 0; i < eventsSize; i++) {
    ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mEvents_)) getWithInt:i]);
    ADAnimatorSet_Node *node = JreRetainedLocalValue(((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mNode_);
    if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED && ((ADAnimatorSet_Node *) nil_chk(node))->mStartTime_ != ADAnimator_DURATION_INFINITE) {
      ADAnimator *animator = JreRetainedLocalValue(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_);
      int64_t start = node->mStartTime_;
      int64_t end = node->mTotalDuration_ == ADAnimator_DURATION_INFINITE ? JavaLangLong_MAX_VALUE : node->mEndTime_;
      if ((start < currentPlayTime && currentPlayTime < end) || (start == currentPlayTime && lastPlayTime < start) || (end == currentPlayTime && lastPlayTime > end)) {
        [((ADAnimator *) nil_chk(animator)) animateValuesInRangeWithLong:currentPlayTime - node->mStartTime_ withLong:JavaLangMath_maxWithLong_withLong_(-1, lastPlayTime - node->mStartTime_)];
      }
    }
  }
}

- (IOSLongArray *)ensureChildStartAndEndTimes {
  return ADAnimatorSet_ensureChildStartAndEndTimes(self);
}

- (void)getStartAndEndTimesWithADLongArray:(ADLongArray *)times
                                  withLong:(int64_t)offset {
  int32_t eventsSize = [((JavaUtilArrayList *) nil_chk(mEvents_)) size];
  for (int32_t i = 0; i < eventsSize; i++) {
    ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mEvents_)) getWithInt:i]);
    if (((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED && ((ADAnimatorSet_Node *) nil_chk(event->mNode_))->mStartTime_ != ADAnimator_DURATION_INFINITE) {
      [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(event->mNode_))->mAnimation_)) getStartAndEndTimesWithADLongArray:times withLong:offset + event->mNode_->mStartTime_];
    }
  }
}

- (bool)isInitialized {
  if (mChildrenInitialized_) {
    return true;
  }
  bool allInitialized = true;
  for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk(mNodes_)) size]; i++) {
    if (![((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:i]))->mAnimation_)) isInitialized]) {
      allInitialized = false;
      break;
    }
  }
  mChildrenInitialized_ = allInitialized;
  return mChildrenInitialized_;
}

- (void)setCurrentPlayTimeWithLong:(int64_t)playTime {
  if (mReversing_ && [self getTotalDuration] == ADAnimator_DURATION_INFINITE) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Error: Cannot seek in reverse in an infinite AnimatorSet");
  }
  if (([self getTotalDuration] != ADAnimator_DURATION_INFINITE && playTime > [self getTotalDuration] - mStartDelay_) || playTime < 0) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Error: Play time should always be in between 0 and duration.");
  }
  ADAnimatorSet_initAnimation(self);
  int64_t lastPlayTime = [((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) getPlayTime];
  if (![self isStarted] || [self isPaused]) {
    if (mReversing_ && ![self isStarted]) {
      @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Error: Something went wrong. mReversing should not be set when AnimatorSet is not started.");
    }
    if (![((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) isActive]) {
      ADAnimatorSet_findLatestEventIdForTimeWithLong_(self, 0);
      ADAnimatorSet_initChildren(self);
      [self skipToEndValueWithBoolean:!mReversing_];
      [((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) setPlayTimeWithLong:0 withBoolean:mReversing_];
    }
  }
  [((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) setPlayTimeWithLong:playTime withBoolean:mReversing_];
  ADAnimatorSet_animateBasedOnPlayTimeWithLong_withLong_withBoolean_(self, playTime, lastPlayTime, mReversing_);
}

- (int64_t)getCurrentPlayTime {
  if ([((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) isActive]) {
    return [((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) getPlayTime];
  }
  if (mLastFrameTime_ == -1) {
    return 0;
  }
  float durationScale = ADValueAnimator_getDurationScale();
  durationScale = durationScale == 0 ? 1 : durationScale;
  if (mReversing_) {
    return JreFpToLong(((mLastFrameTime_ - mFirstFrame_) / durationScale));
  }
  else {
    return JreFpToLong(((mLastFrameTime_ - mFirstFrame_ - mStartDelay_) / durationScale));
  }
}

- (void)initChildren {
  ADAnimatorSet_initChildren(self);
}

- (bool)doAnimationFrameWithLong:(int64_t)frameTime {
  float durationScale = ADValueAnimator_getDurationScale();
  if (durationScale == 0.0f) {
    ADAnimatorSet_forceToEnd(self);
    return true;
  }
  if (mFirstFrame_ < 0) {
    mFirstFrame_ = frameTime;
  }
  if (mPaused_) {
    mPauseTime_ = frameTime;
    ADAnimatorSet_removeAnimationCallback(self);
    return false;
  }
  else if (mPauseTime_ > 0) {
    mFirstFrame_ += (frameTime - mPauseTime_);
    mPauseTime_ = -1;
  }
  if ([((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) isActive]) {
    [((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) updateSeekDirectionWithBoolean:mReversing_];
    if (mReversing_) {
      mFirstFrame_ = JreFpToLong((frameTime - [((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) getPlayTime] * durationScale));
    }
    else {
      mFirstFrame_ = JreFpToLong((frameTime - ([((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) getPlayTime] + mStartDelay_) * durationScale));
    }
    [((ADAnimatorSet_SeekState *) nil_chk(mSeekState_)) reset];
  }
  if (!mReversing_ && frameTime < mFirstFrame_ + mStartDelay_ * durationScale) {
    return false;
  }
  int64_t unscaledPlayTime = JreFpToLong(((frameTime - mFirstFrame_) / durationScale));
  mLastFrameTime_ = frameTime;
  int32_t latestId = ADAnimatorSet_findLatestEventIdForTimeWithLong_(self, unscaledPlayTime);
  int32_t startId = mLastEventId_;
  ADAnimatorSet_handleAnimationEventsWithInt_withInt_withLong_(self, startId, latestId, unscaledPlayTime);
  mLastEventId_ = latestId;
  for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk(mPlayingSet_)) size]; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mPlayingSet_)) getWithInt:i]);
    if (!((ADAnimatorSet_Node *) nil_chk(node))->mEnded_) {
      ADAnimatorSet_pulseFrameWithADAnimatorSet_Node_withLong_(self, node, ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_(self, unscaledPlayTime, node));
    }
  }
  for (int32_t i = [((JavaUtilArrayList *) nil_chk(mPlayingSet_)) size] - 1; i >= 0; i--) {
    if (((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(mPlayingSet_)) getWithInt:i]))->mEnded_) {
      [((JavaUtilArrayList *) nil_chk(mPlayingSet_)) removeWithInt:i];
    }
  }
  bool finished = false;
  if (mReversing_) {
    if ([((JavaUtilArrayList *) nil_chk(mPlayingSet_)) size] == 1 && JreObjectEqualsEquals([((JavaUtilArrayList *) nil_chk(mPlayingSet_)) getWithInt:0], mRootNode_)) {
      finished = true;
    }
    else if ([((JavaUtilArrayList *) nil_chk(mPlayingSet_)) isEmpty] && mLastEventId_ < 3) {
      finished = true;
    }
  }
  else {
    finished = ([((JavaUtilArrayList *) nil_chk(mPlayingSet_)) isEmpty] && mLastEventId_ == [((JavaUtilArrayList *) nil_chk(mEvents_)) size] - 1);
  }
  if (finished) {
    ADAnimatorSet_endAnimation(self);
    return true;
  }
  return false;
}

- (void)commitAnimationFrameWithLong:(int64_t)frameTime {
}

- (bool)pulseAnimationFrameWithLong:(int64_t)frameTime {
  return [self doAnimationFrameWithLong:frameTime];
}

- (void)handleAnimationEventsWithInt:(int32_t)startId
                             withInt:(int32_t)latestId
                            withLong:(int64_t)playTime {
  ADAnimatorSet_handleAnimationEventsWithInt_withInt_withLong_(self, startId, latestId, playTime);
}

- (void)pulseFrameWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node
                                withLong:(int64_t)animPlayTime {
  ADAnimatorSet_pulseFrameWithADAnimatorSet_Node_withLong_(self, node, animPlayTime);
}

- (int64_t)getPlayTimeForNodeIncludingDelayWithLong:(int64_t)overallPlayTime
                             withADAnimatorSet_Node:(ADAnimatorSet_Node *)node {
  return ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_(self, overallPlayTime, node);
}

- (int64_t)getPlayTimeForNodeIncludingDelayWithLong:(int64_t)overallPlayTime
                             withADAnimatorSet_Node:(ADAnimatorSet_Node *)node
                                        withBoolean:(bool)inReverse {
  return ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_withBoolean_(self, overallPlayTime, node, inReverse);
}

- (void)startAnimation {
  ADAnimatorSet_startAnimation(self);
}

- (void)addAnimationEndListener {
  ADAnimatorSet_addAnimationEndListener(self);
}

- (void)removeAnimationEndListener {
  ADAnimatorSet_removeAnimationEndListener(self);
}

- (int32_t)findLatestEventIdForTimeWithLong:(int64_t)currentPlayTime {
  return ADAnimatorSet_findLatestEventIdForTimeWithLong_(self, currentPlayTime);
}

- (void)endAnimation {
  ADAnimatorSet_endAnimation(self);
}

- (void)removeAnimationCallback {
  ADAnimatorSet_removeAnimationCallback(self);
}

- (void)addAnimationCallbackWithLong:(int64_t)delay {
  ADAnimatorSet_addAnimationCallbackWithLong_(self, delay);
}

- (ADAnimatorSet *)java_clone {
  ADAnimatorSet *anim = (ADAnimatorSet *) cast_chk([super java_clone], [ADAnimatorSet class]);
  int32_t nodeCount = [((JavaUtilArrayList *) nil_chk(mNodes_)) size];
  ((ADAnimatorSet *) nil_chk(anim))->mStarted_ = false;
  anim->mLastFrameTime_ = -1;
  anim->mFirstFrame_ = -1;
  anim->mLastEventId_ = -1;
  anim->mPaused_ = false;
  anim->mPauseTime_ = -1;
  JreStrongAssignAndConsume(&anim->mSeekState_, new_ADAnimatorSet_SeekState_initWithADAnimatorSet_(self));
  anim->mSelfPulse_ = true;
  anim->mStartListenersCalled_ = false;
  JreStrongAssignAndConsume(&anim->mPlayingSet_, new_JavaUtilArrayList_init());
  JreStrongAssignAndConsume(&anim->mNodeMap_, new_ADArrayMap_init());
  JreStrongAssignAndConsume(&anim->mNodes_, new_JavaUtilArrayList_initWithInt_(nodeCount));
  JreStrongAssignAndConsume(&anim->mEvents_, new_JavaUtilArrayList_init());
  JreStrongAssignAndConsume(&anim->mAnimationEndListener_, new_ADAnimatorSet_2_initWithADAnimatorSet_(anim));
  anim->mReversing_ = false;
  anim->mDependencyDirty_ = true;
  JavaUtilHashMap *clonesMap = create_JavaUtilHashMap_initWithInt_(nodeCount);
  for (int32_t n = 0; n < nodeCount; n++) {
    ADAnimatorSet_Node *node = [((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:n];
    ADAnimatorSet_Node *nodeClone = JreRetainedLocalValue([((ADAnimatorSet_Node *) nil_chk(node)) java_clone]);
    [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(nodeClone))->mAnimation_)) removeListenerWithADAnimator_AnimatorListener:mAnimationEndListener_];
    [clonesMap putWithId:node withId:nodeClone];
    [((JavaUtilArrayList *) nil_chk(anim->mNodes_)) addWithId:nodeClone];
    [((ADArrayMap *) nil_chk(anim->mNodeMap_)) putWithId:nodeClone->mAnimation_ withId:nodeClone];
  }
  JreStrongAssign(&anim->mRootNode_, [clonesMap getWithId:mRootNode_]);
  JreStrongAssign(&anim->mDelayAnim_, (ADValueAnimator *) cast_chk(((ADAnimatorSet_Node *) nil_chk(anim->mRootNode_))->mAnimation_, [ADValueAnimator class]));
  for (int32_t i = 0; i < nodeCount; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:i]);
    ADAnimatorSet_Node *nodeClone = JreRetainedLocalValue([clonesMap getWithId:node]);
    JreStrongAssign(&((ADAnimatorSet_Node *) nil_chk(nodeClone))->mLatestParent_, ((ADAnimatorSet_Node *) nil_chk(node))->mLatestParent_ == nil ? nil : [clonesMap getWithId:node->mLatestParent_]);
    int32_t size = node->mChildNodes_ == nil ? 0 : [node->mChildNodes_ size];
    for (int32_t j = 0; j < size; j++) {
      [((JavaUtilArrayList *) nil_chk(nodeClone->mChildNodes_)) setWithInt:j withId:[clonesMap getWithId:[node->mChildNodes_ getWithInt:j]]];
    }
    size = node->mSiblings_ == nil ? 0 : [node->mSiblings_ size];
    for (int32_t j = 0; j < size; j++) {
      [((JavaUtilArrayList *) nil_chk(nodeClone->mSiblings_)) setWithInt:j withId:[clonesMap getWithId:[node->mSiblings_ getWithInt:j]]];
    }
    size = node->mParents_ == nil ? 0 : [node->mParents_ size];
    for (int32_t j = 0; j < size; j++) {
      [((JavaUtilArrayList *) nil_chk(nodeClone->mParents_)) setWithInt:j withId:[clonesMap getWithId:[node->mParents_ getWithInt:j]]];
    }
  }
  return anim;
}

- (bool)canReverse {
  return [self getTotalDuration] != ADAnimator_DURATION_INFINITE;
}

- (void)reverse {
  ADAnimatorSet_startWithBoolean_withBoolean_(self, true, true);
}

- (NSString *)description {
  NSString *returnVal = JreStrcat("$$C", @"AnimatorSet@", JavaLangInteger_toHexStringWithInt_(((int32_t) [self hash])), '{');
  int32_t size = [((JavaUtilArrayList *) nil_chk(mNodes_)) size];
  for (int32_t i = 0; i < size; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(mNodes_)) getWithInt:i]);
    JreStrAppend(&returnVal, "$$", @"\n    ", [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_)) description]);
  }
  return JreStrcat("$$", returnVal, @"\n}");
}

- (void)printChildCount {
  ADAnimatorSet_printChildCount(self);
}

- (void)createDependencyGraph {
  ADAnimatorSet_createDependencyGraph(self);
}

- (void)sortAnimationEvents {
  ADAnimatorSet_sortAnimationEvents(self);
}

- (void)updatePlayTimeWithADAnimatorSet_Node:(ADAnimatorSet_Node *)parent
                       withJavaUtilArrayList:(JavaUtilArrayList *)visited {
  ADAnimatorSet_updatePlayTimeWithADAnimatorSet_Node_withJavaUtilArrayList_(self, parent, visited);
}

- (void)findSiblingsWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node
                     withJavaUtilArrayList:(JavaUtilArrayList *)siblings {
  ADAnimatorSet_findSiblingsWithADAnimatorSet_Node_withJavaUtilArrayList_(self, node, siblings);
}

- (bool)shouldPlayTogether {
  ADAnimatorSet_updateAnimatorsDuration(self);
  ADAnimatorSet_createDependencyGraph(self);
  return ((ADAnimatorSet_Node *) nil_chk(mRootNode_))->mChildNodes_ == nil || [mRootNode_->mChildNodes_ size] == [((JavaUtilArrayList *) nil_chk(mNodes_)) size] - 1;
}

- (int64_t)getTotalDuration {
  ADAnimatorSet_updateAnimatorsDuration(self);
  ADAnimatorSet_createDependencyGraph(self);
  return mTotalDuration_;
}

- (ADAnimatorSet_Node *)getNodeForAnimationWithADAnimator:(ADAnimator *)anim {
  return ADAnimatorSet_getNodeForAnimationWithADAnimator_(self, anim);
}

- (void)dealloc {
  RELEASE_(mPlayingSet_);
  RELEASE_(mNodeMap_);
  RELEASE_(mEvents_);
  RELEASE_(mNodes_);
  RELEASE_(mDelayAnim_);
  RELEASE_(mRootNode_);
  RELEASE_(mInterpolator_);
  RELEASE_(mSeekState_);
  RELEASE_(mChildStartAndStopTimes_);
  RELEASE_(mAnimationEndListener_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x81, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 2, -1, 3, -1, -1 },
    { NULL, "V", 0x81, 4, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, 6, -1, -1 },
    { NULL, "LJavaUtilArrayList;", 0x1, -1, -1, -1, 7, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "LADTimeInterpolator;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADAnimatorSet_Builder;", 0x1, 12, 13, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 14, 15, -1, 16, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 17, 18, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADAnimatorSet;", 0x1, 19, 18, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 20, 21, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 22, 23, -1, -1, -1, -1 },
    { NULL, "Z", 0xa, 24, 25, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 26, 21, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 27, 28, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 29, 30, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 31, 32, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 33, 32, -1, -1, -1, -1 },
    { NULL, "[J", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 34, 35, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 36, 18, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 37, 18, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 38, 18, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 39, 18, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 40, 41, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 42, 43, -1, -1, -1, -1 },
    { NULL, "J", 0x2, 44, 45, -1, -1, -1, -1 },
    { NULL, "J", 0x2, 44, 46, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 47, 18, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 48, 18, -1, -1, -1, -1 },
    { NULL, "LADAnimatorSet;", 0x1, 49, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 50, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 51, 52, -1, 53, -1, -1 },
    { NULL, "V", 0x2, 54, 52, -1, 53, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADAnimatorSet_Node;", 0x2, 55, 13, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(playTogetherWithADAnimatorArray:);
  methods[2].selector = @selector(playTogetherWithJavaUtilCollection:);
  methods[3].selector = @selector(playSequentiallyWithADAnimatorArray:);
  methods[4].selector = @selector(playSequentiallyWithJavaUtilList:);
  methods[5].selector = @selector(getChildAnimations);
  methods[6].selector = @selector(setTargetWithId:);
  methods[7].selector = @selector(getChangingConfigurations);
  methods[8].selector = @selector(setInterpolatorWithADTimeInterpolator:);
  methods[9].selector = @selector(getInterpolator);
  methods[10].selector = @selector(playWithADAnimator:);
  methods[11].selector = @selector(cancel);
  methods[12].selector = @selector(callOnPlayingSetWithJavaUtilFunctionConsumer:);
  methods[13].selector = @selector(forceToEnd);
  methods[14].selector = @selector(end);
  methods[15].selector = @selector(isRunning);
  methods[16].selector = @selector(isStarted);
  methods[17].selector = @selector(getStartDelay);
  methods[18].selector = @selector(setStartDelayWithLong:);
  methods[19].selector = @selector(getDuration);
  methods[20].selector = @selector(setDurationWithLong:);
  methods[21].selector = @selector(setupStartValues);
  methods[22].selector = @selector(setupEndValues);
  methods[23].selector = @selector(pause);
  methods[24].selector = @selector(resume);
  methods[25].selector = @selector(start);
  methods[26].selector = @selector(startWithoutPulsingWithBoolean:);
  methods[27].selector = @selector(initAnimation);
  methods[28].selector = @selector(startWithBoolean:withBoolean:);
  methods[29].selector = @selector(isEmptySetWithADAnimatorSet:);
  methods[30].selector = @selector(updateAnimatorsDuration);
  methods[31].selector = @selector(skipToEndValueWithBoolean:);
  methods[32].selector = @selector(animateBasedOnPlayTimeWithLong:withLong:withBoolean:);
  methods[33].selector = @selector(findNextIndexWithLong:withLongArray:);
  methods[34].selector = @selector(animateSkipToEndsWithLong:withLong:);
  methods[35].selector = @selector(animateValuesInRangeWithLong:withLong:);
  methods[36].selector = @selector(ensureChildStartAndEndTimes);
  methods[37].selector = @selector(getStartAndEndTimesWithADLongArray:withLong:);
  methods[38].selector = @selector(isInitialized);
  methods[39].selector = @selector(setCurrentPlayTimeWithLong:);
  methods[40].selector = @selector(getCurrentPlayTime);
  methods[41].selector = @selector(initChildren);
  methods[42].selector = @selector(doAnimationFrameWithLong:);
  methods[43].selector = @selector(commitAnimationFrameWithLong:);
  methods[44].selector = @selector(pulseAnimationFrameWithLong:);
  methods[45].selector = @selector(handleAnimationEventsWithInt:withInt:withLong:);
  methods[46].selector = @selector(pulseFrameWithADAnimatorSet_Node:withLong:);
  methods[47].selector = @selector(getPlayTimeForNodeIncludingDelayWithLong:withADAnimatorSet_Node:);
  methods[48].selector = @selector(getPlayTimeForNodeIncludingDelayWithLong:withADAnimatorSet_Node:withBoolean:);
  methods[49].selector = @selector(startAnimation);
  methods[50].selector = @selector(addAnimationEndListener);
  methods[51].selector = @selector(removeAnimationEndListener);
  methods[52].selector = @selector(findLatestEventIdForTimeWithLong:);
  methods[53].selector = @selector(endAnimation);
  methods[54].selector = @selector(removeAnimationCallback);
  methods[55].selector = @selector(addAnimationCallbackWithLong:);
  methods[56].selector = @selector(java_clone);
  methods[57].selector = @selector(canReverse);
  methods[58].selector = @selector(reverse);
  methods[59].selector = @selector(description);
  methods[60].selector = @selector(printChildCount);
  methods[61].selector = @selector(createDependencyGraph);
  methods[62].selector = @selector(sortAnimationEvents);
  methods[63].selector = @selector(updatePlayTimeWithADAnimatorSet_Node:withJavaUtilArrayList:);
  methods[64].selector = @selector(findSiblingsWithADAnimatorSet_Node:withJavaUtilArrayList:);
  methods[65].selector = @selector(shouldPlayTogether);
  methods[66].selector = @selector(getTotalDuration);
  methods[67].selector = @selector(getNodeForAnimationWithADAnimator:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 56, -1, -1 },
    { "mPlayingSet_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x2, -1, -1, 57, -1 },
    { "mNodeMap_", "LADArrayMap;", .constantValue.asLong = 0, 0x2, -1, -1, 58, -1 },
    { "mEvents_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x2, -1, -1, 59, -1 },
    { "mNodes_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x2, -1, -1, 57, -1 },
    { "mDependencyDirty_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStarted_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStartDelay_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDelayAnim_", "LADValueAnimator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mRootNode_", "LADAnimatorSet_Node;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDuration_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mInterpolator_", "LADTimeInterpolator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTotalDuration_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mShouldIgnoreEndWithoutStart_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mShouldResetValuesAtStart_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mEndCanBeCalled_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mLastFrameTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mFirstFrame_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mLastEventId_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mReversing_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mSelfPulse_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mSeekState_", "LADAnimatorSet_SeekState;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mChildrenInitialized_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mPauseTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mChildStartAndStopTimes_", "[J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAnimationEndListener_", "LADAnimatorListenerAdapter;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "playTogether", "[LADAnimator;", "LJavaUtilCollection;", "(Ljava/util/Collection<Lr/android/animation/Animator;>;)V", "playSequentially", "LJavaUtilList;", "(Ljava/util/List<Lr/android/animation/Animator;>;)V", "()Ljava/util/ArrayList<Lr/android/animation/Animator;>;", "setTarget", "LNSObject;", "setInterpolator", "LADTimeInterpolator;", "play", "LADAnimator;", "callOnPlayingSet", "LJavaUtilFunctionConsumer;", "(Ljava/util/function/Consumer<Lr/android/animation/Animator;>;)V", "setStartDelay", "J", "setDuration", "startWithoutPulsing", "Z", "start", "ZZ", "isEmptySet", "LADAnimatorSet;", "skipToEndValue", "animateBasedOnPlayTime", "JJZ", "findNextIndex", "J[J", "animateSkipToEnds", "JJ", "animateValuesInRange", "getStartAndEndTimes", "LADLongArray;J", "setCurrentPlayTime", "doAnimationFrame", "commitAnimationFrame", "pulseAnimationFrame", "handleAnimationEvents", "IIJ", "pulseFrame", "LADAnimatorSet_Node;J", "getPlayTimeForNodeIncludingDelay", "JLADAnimatorSet_Node;", "JLADAnimatorSet_Node;Z", "findLatestEventIdForTime", "addAnimationCallback", "clone", "toString", "updatePlayTime", "LADAnimatorSet_Node;LJavaUtilArrayList;", "(Lr/android/animation/AnimatorSet$Node;Ljava/util/ArrayList<Lr/android/animation/AnimatorSet$Node;>;)V", "findSiblings", "getNodeForAnimation", &ADAnimatorSet_TAG, "Ljava/util/ArrayList<Lr/android/animation/AnimatorSet$Node;>;", "Lr/android/util/ArrayMap<Lr/android/animation/Animator;Lr/android/animation/AnimatorSet$Node;>;", "Ljava/util/ArrayList<Lr/android/animation/AnimatorSet$AnimationEvent;>;", "LADAnimatorSet_Node;LADAnimatorSet_AnimationEvent;LADAnimatorSet_SeekState;LADAnimatorSet_Builder;" };
  static const J2ObjcClassInfo _ADAnimatorSet = { "AnimatorSet", "r.android.animation", ptrTable, methods, fields, 7, 0x11, 68, 26, -1, 60, -1, -1, -1 };
  return &_ADAnimatorSet;
}

@end

void ADAnimatorSet_init(ADAnimatorSet *self) {
  ADAnimator_init(self);
  JreStrongAssignAndConsume(&self->mPlayingSet_, new_JavaUtilArrayList_init());
  JreStrongAssignAndConsume(&self->mNodeMap_, new_ADArrayMap_init());
  JreStrongAssignAndConsume(&self->mEvents_, new_JavaUtilArrayList_init());
  JreStrongAssignAndConsume(&self->mNodes_, new_JavaUtilArrayList_init());
  self->mDependencyDirty_ = false;
  self->mStarted_ = false;
  self->mStartDelay_ = 0;
  JreStrongAssign(&self->mDelayAnim_, [((ADValueAnimator *) nil_chk(ADValueAnimator_ofFloatWithFloatArray_([IOSFloatArray arrayWithFloats:(float[]){ 0.0f, 1.0f } count:2]))) setDurationWithLong:0]);
  JreStrongAssignAndConsume(&self->mRootNode_, new_ADAnimatorSet_Node_initWithADAnimator_(self->mDelayAnim_));
  self->mDuration_ = -1;
  JreStrongAssign(&self->mInterpolator_, nil);
  self->mTotalDuration_ = 0;
  self->mLastFrameTime_ = -1;
  self->mFirstFrame_ = -1;
  self->mLastEventId_ = -1;
  self->mReversing_ = false;
  self->mSelfPulse_ = true;
  JreStrongAssignAndConsume(&self->mSeekState_, new_ADAnimatorSet_SeekState_initWithADAnimatorSet_(self));
  self->mChildrenInitialized_ = false;
  self->mPauseTime_ = -1;
  JreStrongAssignAndConsume(&self->mAnimationEndListener_, new_ADAnimatorSet_1_initWithADAnimatorSet_(self));
  [((ADArrayMap *) nil_chk(self->mNodeMap_)) putWithId:self->mDelayAnim_ withId:self->mRootNode_];
  [((JavaUtilArrayList *) nil_chk(self->mNodes_)) addWithId:self->mRootNode_];
  bool isPreO;
  ADApplication *app = ADActivityThread_currentApplication();
  if (app == nil || [app getApplicationInfo] == nil) {
    self->mShouldIgnoreEndWithoutStart_ = true;
    isPreO = true;
  }
  else {
    if (((ADApplicationInfo *) nil_chk([app getApplicationInfo]))->targetSdkVersion_ < ADBuild_VERSION_CODES_N) {
      self->mShouldIgnoreEndWithoutStart_ = true;
    }
    else {
      self->mShouldIgnoreEndWithoutStart_ = false;
    }
    isPreO = (((ADApplicationInfo *) nil_chk([app getApplicationInfo]))->targetSdkVersion_ < ADBuild_VERSION_CODES_O);
  }
  self->mShouldResetValuesAtStart_ = !isPreO;
  self->mEndCanBeCalled_ = !isPreO;
}

ADAnimatorSet *new_ADAnimatorSet_init() {
  J2OBJC_NEW_IMPL(ADAnimatorSet, init)
}

ADAnimatorSet *create_ADAnimatorSet_init() {
  J2OBJC_CREATE_IMPL(ADAnimatorSet, init)
}

void ADAnimatorSet_callOnPlayingSetWithJavaUtilFunctionConsumer_(ADAnimatorSet *self, id<JavaUtilFunctionConsumer> consumer) {
  JavaUtilArrayList *list = self->mPlayingSet_;
  int32_t size = [((JavaUtilArrayList *) nil_chk(list)) size];
  for (int32_t i = 0; i < size; i++) {
    ADAnimator *animator = ((ADAnimatorSet_Node *) nil_chk([list getWithInt:i]))->mAnimation_;
    [((id<JavaUtilFunctionConsumer>) nil_chk(consumer)) acceptWithId:animator];
  }
}

void ADAnimatorSet_forceToEnd(ADAnimatorSet *self) {
  if (self->mEndCanBeCalled_) {
    [self end];
    return;
  }
  if (self->mReversing_) {
    ADAnimatorSet_handleAnimationEventsWithInt_withInt_withLong_(self, self->mLastEventId_, 0, [self getTotalDuration]);
  }
  else {
    int64_t zeroScalePlayTime = [self getTotalDuration];
    if (zeroScalePlayTime == ADAnimator_DURATION_INFINITE) {
      zeroScalePlayTime = JavaLangInteger_MAX_VALUE;
    }
    ADAnimatorSet_handleAnimationEventsWithInt_withInt_withLong_(self, self->mLastEventId_, [((JavaUtilArrayList *) nil_chk(self->mEvents_)) size] - 1, zeroScalePlayTime);
  }
  [((JavaUtilArrayList *) nil_chk(self->mPlayingSet_)) clear];
  ADAnimatorSet_endAnimation(self);
}

void ADAnimatorSet_initAnimation(ADAnimatorSet *self) {
  if (self->mInterpolator_ != nil) {
    for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk(self->mNodes_)) size]; i++) {
      ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]);
      [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_)) setInterpolatorWithADTimeInterpolator:self->mInterpolator_];
    }
  }
  ADAnimatorSet_updateAnimatorsDuration(self);
  ADAnimatorSet_createDependencyGraph(self);
}

void ADAnimatorSet_startWithBoolean_withBoolean_(ADAnimatorSet *self, bool inReverse, bool selfPulse) {
  if (ADLooper_myLooper() == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Animators may only be run on Looper threads");
  }
  if (inReverse == self->mReversing_ && selfPulse == self->mSelfPulse_ && self->mStarted_) {
    return;
  }
  self->mStarted_ = true;
  self->mSelfPulse_ = selfPulse;
  self->mPaused_ = false;
  self->mPauseTime_ = -1;
  int32_t size = [((JavaUtilArrayList *) nil_chk(self->mNodes_)) size];
  for (int32_t i = 0; i < size; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]);
    ((ADAnimatorSet_Node *) nil_chk(node))->mEnded_ = false;
    [((ADAnimator *) nil_chk(node->mAnimation_)) setAllowRunningAsynchronouslyWithBoolean:false];
  }
  ADAnimatorSet_initAnimation(self);
  if (inReverse && ![self canReverse]) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Cannot reverse infinite AnimatorSet");
  }
  self->mReversing_ = inReverse;
  bool isEmptySet = ADAnimatorSet_isEmptySetWithADAnimatorSet_(self);
  if (!isEmptySet) {
    ADAnimatorSet_startAnimation(self);
  }
  [self notifyStartListenersWithBoolean:inReverse];
  if (isEmptySet) {
    [self end];
  }
}

bool ADAnimatorSet_isEmptySetWithADAnimatorSet_(ADAnimatorSet *set) {
  ADAnimatorSet_initialize();
  if ([((ADAnimatorSet *) nil_chk(set)) getStartDelay] > 0) {
    return false;
  }
  for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk([set getChildAnimations])) size]; i++) {
    ADAnimator *anim = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk([set getChildAnimations])) getWithInt:i]);
    if (!([anim isKindOfClass:[ADAnimatorSet class]])) {
      return false;
    }
    else {
      if (!ADAnimatorSet_isEmptySetWithADAnimatorSet_((ADAnimatorSet *) cast_chk(anim, [ADAnimatorSet class]))) {
        return false;
      }
    }
  }
  return true;
}

void ADAnimatorSet_updateAnimatorsDuration(ADAnimatorSet *self) {
  if (self->mDuration_ >= 0) {
    int32_t size = [((JavaUtilArrayList *) nil_chk(self->mNodes_)) size];
    for (int32_t i = 0; i < size; i++) {
      ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]);
      [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_)) setDurationWithLong:self->mDuration_];
    }
  }
  [((ADValueAnimator *) nil_chk(self->mDelayAnim_)) setDurationWithLong:self->mStartDelay_];
}

void ADAnimatorSet_animateBasedOnPlayTimeWithLong_withLong_withBoolean_(ADAnimatorSet *self, int64_t currentPlayTime, int64_t lastPlayTime, bool inReverse) {
  if (currentPlayTime < 0 || lastPlayTime < -1) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Error: Play time should never be negative.");
  }
  if (inReverse) {
    int64_t duration = [self getTotalDuration];
    if (duration == ADAnimator_DURATION_INFINITE) {
      @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Cannot reverse AnimatorSet with infinite duration");
    }
    currentPlayTime = JavaLangMath_minWithLong_withLong_(currentPlayTime, duration);
    currentPlayTime = duration - currentPlayTime;
    lastPlayTime = duration - lastPlayTime;
  }
  IOSLongArray *startEndTimes = ADAnimatorSet_ensureChildStartAndEndTimes(self);
  int32_t index = ADAnimatorSet_findNextIndexWithLong_withLongArray_(self, lastPlayTime, startEndTimes);
  int32_t endIndex = ADAnimatorSet_findNextIndexWithLong_withLongArray_(self, currentPlayTime, startEndTimes);
  if (currentPlayTime >= lastPlayTime) {
    while (index < endIndex) {
      int64_t playTime = IOSLongArray_Get(nil_chk(startEndTimes), index);
      if (lastPlayTime != playTime) {
        [self animateSkipToEndsWithLong:playTime withLong:lastPlayTime];
        [self animateValuesInRangeWithLong:playTime withLong:lastPlayTime];
        lastPlayTime = playTime;
      }
      index++;
    }
  }
  else {
    while (index > endIndex) {
      index--;
      int64_t playTime = IOSLongArray_Get(nil_chk(startEndTimes), index);
      if (lastPlayTime != playTime) {
        [self animateSkipToEndsWithLong:playTime withLong:lastPlayTime];
        [self animateValuesInRangeWithLong:playTime withLong:lastPlayTime];
        lastPlayTime = playTime;
      }
    }
  }
  if (currentPlayTime != lastPlayTime) {
    [self animateSkipToEndsWithLong:currentPlayTime withLong:lastPlayTime];
    [self animateValuesInRangeWithLong:currentPlayTime withLong:lastPlayTime];
  }
}

int32_t ADAnimatorSet_findNextIndexWithLong_withLongArray_(ADAnimatorSet *self, int64_t playTime, IOSLongArray *startEndTimes) {
  int32_t index = JavaUtilArrays_binarySearchWithLongArray_withLong_(startEndTimes, playTime);
  if (index < 0) {
    index = -index - 1;
  }
  else {
    index++;
  }
  return index;
}

IOSLongArray *ADAnimatorSet_ensureChildStartAndEndTimes(ADAnimatorSet *self) {
  if (self->mChildStartAndStopTimes_ == nil) {
    ADLongArray *startAndEndTimes = create_ADLongArray_init();
    [self getStartAndEndTimesWithADLongArray:startAndEndTimes withLong:0];
    IOSLongArray *times = [startAndEndTimes toArray];
    JavaUtilArrays_sortWithLongArray_(times);
    JreStrongAssign(&self->mChildStartAndStopTimes_, times);
  }
  return self->mChildStartAndStopTimes_;
}

void ADAnimatorSet_initChildren(ADAnimatorSet *self) {
  if (![self isInitialized]) {
    self->mChildrenInitialized_ = true;
    [self skipToEndValueWithBoolean:false];
  }
}

void ADAnimatorSet_handleAnimationEventsWithInt_withInt_withLong_(ADAnimatorSet *self, int32_t startId, int32_t latestId, int64_t playTime) {
  if (self->mReversing_) {
    startId = startId == -1 ? [((JavaUtilArrayList *) nil_chk(self->mEvents_)) size] : startId;
    for (int32_t i = startId - 1; i >= latestId; i--) {
      ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:i]);
      ADAnimatorSet_Node *node = JreRetainedLocalValue(((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mNode_);
      if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_END) {
        if ([((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_)) isStarted]) {
          [((ADAnimator *) nil_chk(node->mAnimation_)) cancel];
        }
        node->mEnded_ = false;
        [((JavaUtilArrayList *) nil_chk(self->mPlayingSet_)) addWithId:event->mNode_];
        [((ADAnimator *) nil_chk(node->mAnimation_)) startWithoutPulsingWithBoolean:true];
        ADAnimatorSet_pulseFrameWithADAnimatorSet_Node_withLong_(self, node, 0);
      }
      else if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED && !((ADAnimatorSet_Node *) nil_chk(node))->mEnded_) {
        ADAnimatorSet_pulseFrameWithADAnimatorSet_Node_withLong_(self, node, ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_(self, playTime, node));
      }
    }
  }
  else {
    for (int32_t i = startId + 1; i <= latestId; i++) {
      ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:i]);
      ADAnimatorSet_Node *node = JreRetainedLocalValue(((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mNode_);
      if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_START) {
        [((JavaUtilArrayList *) nil_chk(self->mPlayingSet_)) addWithId:event->mNode_];
        if ([((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_)) isStarted]) {
          [((ADAnimator *) nil_chk(node->mAnimation_)) cancel];
        }
        node->mEnded_ = false;
        [((ADAnimator *) nil_chk(node->mAnimation_)) startWithoutPulsingWithBoolean:false];
        ADAnimatorSet_pulseFrameWithADAnimatorSet_Node_withLong_(self, node, 0);
      }
      else if (event->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_END && !((ADAnimatorSet_Node *) nil_chk(node))->mEnded_) {
        ADAnimatorSet_pulseFrameWithADAnimatorSet_Node_withLong_(self, node, ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_(self, playTime, node));
      }
    }
  }
}

void ADAnimatorSet_pulseFrameWithADAnimatorSet_Node_withLong_(ADAnimatorSet *self, ADAnimatorSet_Node *node, int64_t animPlayTime) {
  if (!((ADAnimatorSet_Node *) nil_chk(node))->mEnded_) {
    float durationScale = ADValueAnimator_getDurationScale();
    durationScale = durationScale == 0 ? 1 : durationScale;
    node->mEnded_ = [((ADAnimator *) nil_chk(node->mAnimation_)) pulseAnimationFrameWithLong:JreFpToLong((animPlayTime * durationScale))];
  }
}

int64_t ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_(ADAnimatorSet *self, int64_t overallPlayTime, ADAnimatorSet_Node *node) {
  return ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_withBoolean_(self, overallPlayTime, node, self->mReversing_);
}

int64_t ADAnimatorSet_getPlayTimeForNodeIncludingDelayWithLong_withADAnimatorSet_Node_withBoolean_(ADAnimatorSet *self, int64_t overallPlayTime, ADAnimatorSet_Node *node, bool inReverse) {
  if (inReverse) {
    overallPlayTime = [self getTotalDuration] - overallPlayTime;
    return ((ADAnimatorSet_Node *) nil_chk(node))->mEndTime_ - overallPlayTime;
  }
  else {
    return overallPlayTime - ((ADAnimatorSet_Node *) nil_chk(node))->mStartTime_;
  }
}

void ADAnimatorSet_startAnimation(ADAnimatorSet *self) {
  ADAnimatorSet_addAnimationEndListener(self);
  ADAnimatorSet_addAnimationCallbackWithLong_(self, 0);
  if ([((ADAnimatorSet_SeekState *) nil_chk(self->mSeekState_)) getPlayTimeNormalized] == 0 && self->mReversing_) {
    [((ADAnimatorSet_SeekState *) nil_chk(self->mSeekState_)) reset];
  }
  if (self->mShouldResetValuesAtStart_) {
    if ([self isInitialized]) {
      [self skipToEndValueWithBoolean:!self->mReversing_];
    }
    else if (self->mReversing_) {
      ADAnimatorSet_initChildren(self);
      [self skipToEndValueWithBoolean:!self->mReversing_];
    }
    else {
      for (int32_t i = [((JavaUtilArrayList *) nil_chk(self->mEvents_)) size] - 1; i >= 0; i--) {
        if (((ADAnimatorSet_AnimationEvent *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:i]))->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED) {
          ADAnimator *anim = JreRetainedLocalValue(((ADAnimatorSet_Node *) nil_chk(((ADAnimatorSet_AnimationEvent *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:i]))->mNode_))->mAnimation_);
          if ([((ADAnimator *) nil_chk(anim)) isInitialized]) {
            [anim skipToEndValueWithBoolean:true];
          }
        }
      }
    }
  }
  if (self->mReversing_ || self->mStartDelay_ == 0 || [((ADAnimatorSet_SeekState *) nil_chk(self->mSeekState_)) isActive]) {
    int64_t playTime;
    if ([((ADAnimatorSet_SeekState *) nil_chk(self->mSeekState_)) isActive]) {
      [((ADAnimatorSet_SeekState *) nil_chk(self->mSeekState_)) updateSeekDirectionWithBoolean:self->mReversing_];
      playTime = [((ADAnimatorSet_SeekState *) nil_chk(self->mSeekState_)) getPlayTime];
    }
    else {
      playTime = 0;
    }
    int32_t toId = ADAnimatorSet_findLatestEventIdForTimeWithLong_(self, playTime);
    ADAnimatorSet_handleAnimationEventsWithInt_withInt_withLong_(self, -1, toId, playTime);
    for (int32_t i = [((JavaUtilArrayList *) nil_chk(self->mPlayingSet_)) size] - 1; i >= 0; i--) {
      if (((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mPlayingSet_)) getWithInt:i]))->mEnded_) {
        [((JavaUtilArrayList *) nil_chk(self->mPlayingSet_)) removeWithInt:i];
      }
    }
    self->mLastEventId_ = toId;
  }
}

void ADAnimatorSet_addAnimationEndListener(ADAnimatorSet *self) {
  for (int32_t i = 1; i < [((JavaUtilArrayList *) nil_chk(self->mNodes_)) size]; i++) {
    [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]))->mAnimation_)) addListenerWithADAnimator_AnimatorListener:self->mAnimationEndListener_];
  }
}

void ADAnimatorSet_removeAnimationEndListener(ADAnimatorSet *self) {
  for (int32_t i = 1; i < [((JavaUtilArrayList *) nil_chk(self->mNodes_)) size]; i++) {
    [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]))->mAnimation_)) removeListenerWithADAnimator_AnimatorListener:self->mAnimationEndListener_];
  }
}

int32_t ADAnimatorSet_findLatestEventIdForTimeWithLong_(ADAnimatorSet *self, int64_t currentPlayTime) {
  int32_t size = [((JavaUtilArrayList *) nil_chk(self->mEvents_)) size];
  int32_t latestId = self->mLastEventId_;
  if (self->mReversing_) {
    currentPlayTime = [self getTotalDuration] - currentPlayTime;
    self->mLastEventId_ = self->mLastEventId_ == -1 ? size : self->mLastEventId_;
    for (int32_t j = self->mLastEventId_ - 1; j >= 0; j--) {
      ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:j]);
      if ([((ADAnimatorSet_AnimationEvent *) nil_chk(event)) getTime] >= currentPlayTime) {
        latestId = j;
      }
    }
  }
  else {
    for (int32_t i = self->mLastEventId_ + 1; i < size; i++) {
      ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:i]);
      if ([((ADAnimatorSet_AnimationEvent *) nil_chk(event)) getTime] != ADAnimator_DURATION_INFINITE && [event getTime] <= currentPlayTime) {
        latestId = i;
      }
    }
  }
  return latestId;
}

void ADAnimatorSet_endAnimation(ADAnimatorSet *self) {
  self->mStarted_ = false;
  self->mLastFrameTime_ = -1;
  self->mFirstFrame_ = -1;
  self->mLastEventId_ = -1;
  self->mPaused_ = false;
  self->mPauseTime_ = -1;
  [((ADAnimatorSet_SeekState *) nil_chk(self->mSeekState_)) reset];
  [((JavaUtilArrayList *) nil_chk(self->mPlayingSet_)) clear];
  ADAnimatorSet_removeAnimationCallback(self);
  [self notifyEndListenersWithBoolean:self->mReversing_];
  ADAnimatorSet_removeAnimationEndListener(self);
  self->mSelfPulse_ = true;
  self->mReversing_ = false;
}

void ADAnimatorSet_removeAnimationCallback(ADAnimatorSet *self) {
  if (!self->mSelfPulse_) {
    return;
  }
  ADAnimationHandler *handler = ADAnimationHandler_getInstance();
  [((ADAnimationHandler *) nil_chk(handler)) removeCallbackWithADAnimationHandler_AnimationFrameCallback:self];
}

void ADAnimatorSet_addAnimationCallbackWithLong_(ADAnimatorSet *self, int64_t delay) {
  if (!self->mSelfPulse_) {
    return;
  }
  ADAnimationHandler *handler = ADAnimationHandler_getInstance();
  [((ADAnimationHandler *) nil_chk(handler)) addAnimationFrameCallbackWithADAnimationHandler_AnimationFrameCallback:self withLong:delay];
}

void ADAnimatorSet_printChildCount(ADAnimatorSet *self) {
  JavaUtilArrayList *list = create_JavaUtilArrayList_initWithInt_([((JavaUtilArrayList *) nil_chk(self->mNodes_)) size]);
  [list addWithId:self->mRootNode_];
  ADLog_dWithNSString_withNSString_(ADAnimatorSet_TAG, @"Current tree: ");
  int32_t index = 0;
  while (index < [list size]) {
    int32_t listSize = [list size];
    JavaLangStringBuilder *builder = create_JavaLangStringBuilder_init();
    for (; index < listSize; index++) {
      ADAnimatorSet_Node *node = JreRetainedLocalValue([list getWithInt:index]);
      int32_t num = 0;
      if (((ADAnimatorSet_Node *) nil_chk(node))->mChildNodes_ != nil) {
        for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk(node->mChildNodes_)) size]; i++) {
          ADAnimatorSet_Node *child = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(node->mChildNodes_)) getWithInt:i]);
          if (JreObjectEqualsEquals(((ADAnimatorSet_Node *) nil_chk(child))->mLatestParent_, node)) {
            num++;
            [list addWithId:child];
          }
        }
      }
      [builder appendWithNSString:@" "];
      [builder appendWithInt:num];
    }
    ADLog_dWithNSString_withNSString_(ADAnimatorSet_TAG, [builder description]);
  }
}

void ADAnimatorSet_createDependencyGraph(ADAnimatorSet *self) {
  if (!self->mDependencyDirty_) {
    bool durationChanged = false;
    for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk(self->mNodes_)) size]; i++) {
      ADAnimator *anim = JreRetainedLocalValue(((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]))->mAnimation_);
      if (((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]))->mTotalDuration_ != [((ADAnimator *) nil_chk(anim)) getTotalDuration]) {
        durationChanged = true;
        break;
      }
    }
    if (!durationChanged) {
      return;
    }
  }
  self->mDependencyDirty_ = false;
  int32_t size = [((JavaUtilArrayList *) nil_chk(self->mNodes_)) size];
  for (int32_t i = 0; i < size; i++) {
    ((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]))->mParentsAdded_ = false;
  }
  for (int32_t i = 0; i < size; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]);
    if (((ADAnimatorSet_Node *) nil_chk(node))->mParentsAdded_) {
      continue;
    }
    node->mParentsAdded_ = true;
    if (node->mSiblings_ == nil) {
      continue;
    }
    ADAnimatorSet_findSiblingsWithADAnimatorSet_Node_withJavaUtilArrayList_(self, node, node->mSiblings_);
    [((JavaUtilArrayList *) nil_chk(node->mSiblings_)) removeWithId:node];
    int32_t siblingSize = [((JavaUtilArrayList *) nil_chk(node->mSiblings_)) size];
    for (int32_t j = 0; j < siblingSize; j++) {
      [node addParentsWithJavaUtilArrayList:((ADAnimatorSet_Node *) nil_chk([((JavaUtilArrayList *) nil_chk(node->mSiblings_)) getWithInt:j]))->mParents_];
    }
    for (int32_t j = 0; j < siblingSize; j++) {
      ADAnimatorSet_Node *sibling = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(node->mSiblings_)) getWithInt:j]);
      [((ADAnimatorSet_Node *) nil_chk(sibling)) addParentsWithJavaUtilArrayList:node->mParents_];
      sibling->mParentsAdded_ = true;
    }
  }
  for (int32_t i = 0; i < size; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]);
    if (!JreObjectEqualsEquals(node, self->mRootNode_) && ((ADAnimatorSet_Node *) nil_chk(node))->mParents_ == nil) {
      [((ADAnimatorSet_Node *) nil_chk(node)) addParentWithADAnimatorSet_Node:self->mRootNode_];
    }
  }
  JavaUtilArrayList *visited = create_JavaUtilArrayList_initWithInt_([((JavaUtilArrayList *) nil_chk(self->mNodes_)) size]);
  ((ADAnimatorSet_Node *) nil_chk(self->mRootNode_))->mStartTime_ = 0;
  self->mRootNode_->mEndTime_ = [((ADValueAnimator *) nil_chk(self->mDelayAnim_)) getDuration];
  ADAnimatorSet_updatePlayTimeWithADAnimatorSet_Node_withJavaUtilArrayList_(self, self->mRootNode_, visited);
  ADAnimatorSet_sortAnimationEvents(self);
  self->mTotalDuration_ = [((ADAnimatorSet_AnimationEvent *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:[self->mEvents_ size] - 1])) getTime];
}

void ADAnimatorSet_sortAnimationEvents(ADAnimatorSet *self) {
  [((JavaUtilArrayList *) nil_chk(self->mEvents_)) clear];
  for (int32_t i = 1; i < [((JavaUtilArrayList *) nil_chk(self->mNodes_)) size]; i++) {
    ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]);
    [((JavaUtilArrayList *) nil_chk(self->mEvents_)) addWithId:create_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(node, ADAnimatorSet_AnimationEvent_ANIMATION_START)];
    [((JavaUtilArrayList *) nil_chk(self->mEvents_)) addWithId:create_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(node, ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED)];
    [((JavaUtilArrayList *) nil_chk(self->mEvents_)) addWithId:create_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(node, ADAnimatorSet_AnimationEvent_ANIMATION_END)];
  }
  [((JavaUtilArrayList *) nil_chk(self->mEvents_)) sortWithJavaUtilComparator:create_ADAnimatorSet_3_init()];
  int32_t eventSize = [((JavaUtilArrayList *) nil_chk(self->mEvents_)) size];
  for (int32_t i = 0; i < eventSize; ) {
    ADAnimatorSet_AnimationEvent *event = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:i]);
    if (((ADAnimatorSet_AnimationEvent *) nil_chk(event))->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_END) {
      bool needToSwapStart;
      if (((ADAnimatorSet_Node *) nil_chk(event->mNode_))->mStartTime_ == event->mNode_->mEndTime_) {
        needToSwapStart = true;
      }
      else if (event->mNode_->mEndTime_ == event->mNode_->mStartTime_ + [((ADAnimator *) nil_chk(event->mNode_->mAnimation_)) getStartDelay]) {
        needToSwapStart = false;
      }
      else {
        i++;
        continue;
      }
      int32_t startEventId = eventSize;
      int32_t startDelayEndId = eventSize;
      for (int32_t j = i + 1; j < eventSize; j++) {
        if (startEventId < eventSize && startDelayEndId < eventSize) {
          break;
        }
        if (JreObjectEqualsEquals(((ADAnimatorSet_AnimationEvent *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:j]))->mNode_, event->mNode_)) {
          if (((ADAnimatorSet_AnimationEvent *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:j]))->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_START) {
            startEventId = j;
          }
          else if (((ADAnimatorSet_AnimationEvent *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:j]))->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED) {
            startDelayEndId = j;
          }
        }
      }
      if (needToSwapStart && startEventId == [((JavaUtilArrayList *) nil_chk(self->mEvents_)) size]) {
        @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Something went wrong, no start isfound after stop for an animation that has the same start and endtime.");
      }
      if (startDelayEndId == [((JavaUtilArrayList *) nil_chk(self->mEvents_)) size]) {
        @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Something went wrong, no startdelay end is found after stop for an animation");
      }
      if (needToSwapStart) {
        ADAnimatorSet_AnimationEvent *startEvent = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mEvents_)) removeWithInt:startEventId]);
        [((JavaUtilArrayList *) nil_chk(self->mEvents_)) addWithInt:i withId:startEvent];
        i++;
      }
      ADAnimatorSet_AnimationEvent *startDelayEndEvent = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mEvents_)) removeWithInt:startDelayEndId]);
      [((JavaUtilArrayList *) nil_chk(self->mEvents_)) addWithInt:i withId:startDelayEndEvent];
      i += 2;
    }
    else {
      i++;
    }
  }
  if (![((JavaUtilArrayList *) nil_chk(self->mEvents_)) isEmpty] && ((ADAnimatorSet_AnimationEvent *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:0]))->mEvent_ != ADAnimatorSet_AnimationEvent_ANIMATION_START) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Sorting went bad, the start event should always be at index 0");
  }
  [((JavaUtilArrayList *) nil_chk(self->mEvents_)) addWithInt:0 withId:create_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(self->mRootNode_, ADAnimatorSet_AnimationEvent_ANIMATION_START)];
  [((JavaUtilArrayList *) nil_chk(self->mEvents_)) addWithInt:1 withId:create_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(self->mRootNode_, ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED)];
  [((JavaUtilArrayList *) nil_chk(self->mEvents_)) addWithInt:2 withId:create_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(self->mRootNode_, ADAnimatorSet_AnimationEvent_ANIMATION_END)];
  if (((ADAnimatorSet_AnimationEvent *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:[self->mEvents_ size] - 1]))->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_START || ((ADAnimatorSet_AnimationEvent *) nil_chk([((JavaUtilArrayList *) nil_chk(self->mEvents_)) getWithInt:[self->mEvents_ size] - 1]))->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Something went wrong, the last event is not an end event");
  }
}

void ADAnimatorSet_updatePlayTimeWithADAnimatorSet_Node_withJavaUtilArrayList_(ADAnimatorSet *self, ADAnimatorSet_Node *parent, JavaUtilArrayList *visited) {
  if (((ADAnimatorSet_Node *) nil_chk(parent))->mChildNodes_ == nil) {
    if (JreObjectEqualsEquals(parent, self->mRootNode_)) {
      for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk(self->mNodes_)) size]; i++) {
        ADAnimatorSet_Node *node = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(self->mNodes_)) getWithInt:i]);
        if (!JreObjectEqualsEquals(node, self->mRootNode_)) {
          ((ADAnimatorSet_Node *) nil_chk(node))->mStartTime_ = ADAnimator_DURATION_INFINITE;
          node->mEndTime_ = ADAnimator_DURATION_INFINITE;
        }
      }
    }
    return;
  }
  [((JavaUtilArrayList *) nil_chk(visited)) addWithId:parent];
  int32_t childrenSize = [((JavaUtilArrayList *) nil_chk(parent->mChildNodes_)) size];
  for (int32_t i = 0; i < childrenSize; i++) {
    ADAnimatorSet_Node *child = JreRetainedLocalValue([((JavaUtilArrayList *) nil_chk(parent->mChildNodes_)) getWithInt:i]);
    ((ADAnimatorSet_Node *) nil_chk(child))->mTotalDuration_ = [((ADAnimator *) nil_chk(child->mAnimation_)) getTotalDuration];
    int32_t index = [visited indexOfWithId:child];
    if (index >= 0) {
      for (int32_t j = index; j < [visited size]; j++) {
        JreStrongAssign(&((ADAnimatorSet_Node *) nil_chk([visited getWithInt:j]))->mLatestParent_, nil);
        ((ADAnimatorSet_Node *) nil_chk([visited getWithInt:j]))->mStartTime_ = ADAnimator_DURATION_INFINITE;
        ((ADAnimatorSet_Node *) nil_chk([visited getWithInt:j]))->mEndTime_ = ADAnimator_DURATION_INFINITE;
      }
      child->mStartTime_ = ADAnimator_DURATION_INFINITE;
      child->mEndTime_ = ADAnimator_DURATION_INFINITE;
      JreStrongAssign(&child->mLatestParent_, nil);
      ADLog_wWithNSString_withNSString_(ADAnimatorSet_TAG, JreStrcat("$@", @"Cycle found in AnimatorSet: ", self));
      continue;
    }
    if (child->mStartTime_ != ADAnimator_DURATION_INFINITE) {
      if (parent->mEndTime_ == ADAnimator_DURATION_INFINITE) {
        JreStrongAssign(&child->mLatestParent_, parent);
        child->mStartTime_ = ADAnimator_DURATION_INFINITE;
        child->mEndTime_ = ADAnimator_DURATION_INFINITE;
      }
      else {
        if (parent->mEndTime_ >= child->mStartTime_) {
          JreStrongAssign(&child->mLatestParent_, parent);
          child->mStartTime_ = parent->mEndTime_;
        }
        child->mEndTime_ = child->mTotalDuration_ == ADAnimator_DURATION_INFINITE ? ADAnimator_DURATION_INFINITE : child->mStartTime_ + child->mTotalDuration_;
      }
    }
    ADAnimatorSet_updatePlayTimeWithADAnimatorSet_Node_withJavaUtilArrayList_(self, child, visited);
  }
  [visited removeWithId:parent];
}

void ADAnimatorSet_findSiblingsWithADAnimatorSet_Node_withJavaUtilArrayList_(ADAnimatorSet *self, ADAnimatorSet_Node *node, JavaUtilArrayList *siblings) {
  if (![((JavaUtilArrayList *) nil_chk(siblings)) containsWithId:node]) {
    [siblings addWithId:node];
    if (((ADAnimatorSet_Node *) nil_chk(node))->mSiblings_ == nil) {
      return;
    }
    for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk(node->mSiblings_)) size]; i++) {
      ADAnimatorSet_findSiblingsWithADAnimatorSet_Node_withJavaUtilArrayList_(self, [((JavaUtilArrayList *) nil_chk(node->mSiblings_)) getWithInt:i], siblings);
    }
  }
}

ADAnimatorSet_Node *ADAnimatorSet_getNodeForAnimationWithADAnimator_(ADAnimatorSet *self, ADAnimator *anim) {
  ADAnimatorSet_Node *node = JreRetainedLocalValue([((ADArrayMap *) nil_chk(self->mNodeMap_)) getWithId:anim]);
  if (node == nil) {
    node = create_ADAnimatorSet_Node_initWithADAnimator_(anim);
    [((ADArrayMap *) nil_chk(self->mNodeMap_)) putWithId:anim withId:node];
    [((JavaUtilArrayList *) nil_chk(self->mNodes_)) addWithId:node];
  }
  return node;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADAnimatorSet)

J2OBJC_NAME_MAPPING(ADAnimatorSet, "r.android.animation", "AD")

@implementation ADAnimatorSet_1

- (instancetype)initWithADAnimatorSet:(ADAnimatorSet *)outer$ {
  ADAnimatorSet_1_initWithADAnimatorSet_(self, outer$);
  return self;
}

- (void)onAnimationEndWithADAnimator:(ADAnimator *)animation {
  if ([((ADArrayMap *) nil_chk(this$0_->mNodeMap_)) getWithId:animation] == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Error: animation ended is not in the node map");
  }
  ((ADAnimatorSet_Node *) nil_chk([((ADArrayMap *) nil_chk(this$0_->mNodeMap_)) getWithId:animation]))->mEnded_ = true;
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADAnimatorSet:);
  methods[1].selector = @selector(onAnimationEndWithADAnimator:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LADAnimatorSet;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADAnimatorSet;", "onAnimationEnd", "LADAnimator;" };
  static const J2ObjcClassInfo _ADAnimatorSet_1 = { "", "r.android.animation", ptrTable, methods, fields, 7, 0x8000, 2, 1, 0, -1, -1, -1, -1 };
  return &_ADAnimatorSet_1;
}

@end

void ADAnimatorSet_1_initWithADAnimatorSet_(ADAnimatorSet_1 *self, ADAnimatorSet *outer$) {
  JreStrongAssign(&self->this$0_, outer$);
  ADAnimatorListenerAdapter_init(self);
}

ADAnimatorSet_1 *new_ADAnimatorSet_1_initWithADAnimatorSet_(ADAnimatorSet *outer$) {
  J2OBJC_NEW_IMPL(ADAnimatorSet_1, initWithADAnimatorSet_, outer$)
}

ADAnimatorSet_1 *create_ADAnimatorSet_1_initWithADAnimatorSet_(ADAnimatorSet *outer$) {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_1, initWithADAnimatorSet_, outer$)
}

@implementation ADAnimatorSet_2

- (instancetype)initWithADAnimatorSet:(ADAnimatorSet *)capture$0 {
  ADAnimatorSet_2_initWithADAnimatorSet_(self, capture$0);
  return self;
}

- (void)onAnimationEndWithADAnimator:(ADAnimator *)animation {
  if ([((ADArrayMap *) nil_chk(((ADAnimatorSet *) nil_chk(val$anim_))->mNodeMap_)) getWithId:animation] == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Error: animation ended is not in the node map");
  }
  ((ADAnimatorSet_Node *) nil_chk([((ADArrayMap *) nil_chk(val$anim_->mNodeMap_)) getWithId:animation]))->mEnded_ = true;
}

- (void)dealloc {
  RELEASE_(val$anim_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADAnimatorSet:);
  methods[1].selector = @selector(onAnimationEndWithADAnimator:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$anim_", "LADAnimatorSet;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADAnimatorSet;", "onAnimationEnd", "LADAnimator;", "java_clone" };
  static const J2ObjcClassInfo _ADAnimatorSet_2 = { "", "r.android.animation", ptrTable, methods, fields, 7, 0x8000, 2, 1, 0, -1, 3, -1, -1 };
  return &_ADAnimatorSet_2;
}

@end

void ADAnimatorSet_2_initWithADAnimatorSet_(ADAnimatorSet_2 *self, ADAnimatorSet *capture$0) {
  JreStrongAssign(&self->val$anim_, capture$0);
  ADAnimatorListenerAdapter_init(self);
}

ADAnimatorSet_2 *new_ADAnimatorSet_2_initWithADAnimatorSet_(ADAnimatorSet *capture$0) {
  J2OBJC_NEW_IMPL(ADAnimatorSet_2, initWithADAnimatorSet_, capture$0)
}

ADAnimatorSet_2 *create_ADAnimatorSet_2_initWithADAnimatorSet_(ADAnimatorSet *capture$0) {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_2, initWithADAnimatorSet_, capture$0)
}

@implementation ADAnimatorSet_3

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADAnimatorSet_3_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (int32_t)compareWithId:(ADAnimatorSet_AnimationEvent *)e1
                  withId:(ADAnimatorSet_AnimationEvent *)e2 {
  int64_t t1 = [((ADAnimatorSet_AnimationEvent *) nil_chk(e1)) getTime];
  int64_t t2 = [((ADAnimatorSet_AnimationEvent *) nil_chk(e2)) getTime];
  if (t1 == t2) {
    if (e2->mEvent_ + e1->mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_START + ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED) {
      return e1->mEvent_ - e2->mEvent_;
    }
    else {
      return e2->mEvent_ - e1->mEvent_;
    }
  }
  if (t2 == ADAnimator_DURATION_INFINITE) {
    return -1;
  }
  if (t1 == ADAnimator_DURATION_INFINITE) {
    return 1;
  }
  return (int32_t) (t1 - t2);
}

- (id<JavaUtilComparator>)reversed {
  return JavaUtilComparator_reversed(self);
}

- (id<JavaUtilComparator>)thenComparingWithJavaUtilComparator:(id<JavaUtilComparator>)arg0 {
  return JavaUtilComparator_thenComparingWithJavaUtilComparator_(self, arg0);
}

- (id<JavaUtilComparator>)thenComparingWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0
                                             withJavaUtilComparator:(id<JavaUtilComparator>)arg1 {
  return JavaUtilComparator_thenComparingWithJavaUtilFunctionFunction_withJavaUtilComparator_(self, arg0, arg1);
}

- (id<JavaUtilComparator>)thenComparingWithJavaUtilFunctionFunction:(id<JavaUtilFunctionFunction>)arg0 {
  return JavaUtilComparator_thenComparingWithJavaUtilFunctionFunction_(self, arg0);
}

- (id<JavaUtilComparator>)thenComparingIntWithJavaUtilFunctionToIntFunction:(id<JavaUtilFunctionToIntFunction>)arg0 {
  return JavaUtilComparator_thenComparingIntWithJavaUtilFunctionToIntFunction_(self, arg0);
}

- (id<JavaUtilComparator>)thenComparingLongWithJavaUtilFunctionToLongFunction:(id<JavaUtilFunctionToLongFunction>)arg0 {
  return JavaUtilComparator_thenComparingLongWithJavaUtilFunctionToLongFunction_(self, arg0);
}

- (id<JavaUtilComparator>)thenComparingDoubleWithJavaUtilFunctionToDoubleFunction:(id<JavaUtilFunctionToDoubleFunction>)arg0 {
  return JavaUtilComparator_thenComparingDoubleWithJavaUtilFunctionToDoubleFunction_(self, arg0);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(compareWithId:withId:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "compare", "LADAnimatorSet_AnimationEvent;LADAnimatorSet_AnimationEvent;", "LADAnimatorSet;", "sortAnimationEvents", "Ljava/lang/Object;Ljava/util/Comparator<Lr/android/animation/AnimatorSet$AnimationEvent;>;" };
  static const J2ObjcClassInfo _ADAnimatorSet_3 = { "", "r.android.animation", ptrTable, methods, NULL, 7, 0x8000, 2, 0, 2, -1, 3, 4, -1 };
  return &_ADAnimatorSet_3;
}

@end

void ADAnimatorSet_3_init(ADAnimatorSet_3 *self) {
  NSObject_init(self);
}

ADAnimatorSet_3 *new_ADAnimatorSet_3_init() {
  J2OBJC_NEW_IMPL(ADAnimatorSet_3, init)
}

ADAnimatorSet_3 *create_ADAnimatorSet_3_init() {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_3, init)
}

@implementation ADAnimatorSet_Node

- (instancetype)initWithADAnimator:(ADAnimator *)animation {
  ADAnimatorSet_Node_initWithADAnimator_(self, animation);
  return self;
}

- (ADAnimatorSet_Node *)java_clone {
  @try {
    ADAnimatorSet_Node *node = (ADAnimatorSet_Node *) cast_chk([super java_clone], [ADAnimatorSet_Node class]);
    JreStrongAssign(&((ADAnimatorSet_Node *) nil_chk(node))->mAnimation_, [((ADAnimator *) nil_chk(mAnimation_)) java_clone]);
    if (mChildNodes_ != nil) {
      JreStrongAssignAndConsume(&node->mChildNodes_, new_JavaUtilArrayList_initWithJavaUtilCollection_(mChildNodes_));
    }
    if (mSiblings_ != nil) {
      JreStrongAssignAndConsume(&node->mSiblings_, new_JavaUtilArrayList_initWithJavaUtilCollection_(mSiblings_));
    }
    if (mParents_ != nil) {
      JreStrongAssignAndConsume(&node->mParents_, new_JavaUtilArrayList_initWithJavaUtilCollection_(mParents_));
    }
    node->mEnded_ = false;
    return node;
  }
  @catch (JavaLangCloneNotSupportedException *e) {
    @throw create_JavaLangAssertionError_init();
  }
}

- (void)addChildWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node {
  if (mChildNodes_ == nil) {
    JreStrongAssignAndConsume(&mChildNodes_, new_JavaUtilArrayList_init());
  }
  if (![mChildNodes_ containsWithId:node]) {
    [((JavaUtilArrayList *) nil_chk(mChildNodes_)) addWithId:node];
    [((ADAnimatorSet_Node *) nil_chk(node)) addParentWithADAnimatorSet_Node:self];
  }
}

- (void)addSiblingWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node {
  if (mSiblings_ == nil) {
    JreStrongAssignAndConsume(&mSiblings_, new_JavaUtilArrayList_init());
  }
  if (![mSiblings_ containsWithId:node]) {
    [((JavaUtilArrayList *) nil_chk(mSiblings_)) addWithId:node];
    [((ADAnimatorSet_Node *) nil_chk(node)) addSiblingWithADAnimatorSet_Node:self];
  }
}

- (void)addParentWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node {
  if (mParents_ == nil) {
    JreStrongAssignAndConsume(&mParents_, new_JavaUtilArrayList_init());
  }
  if (![mParents_ containsWithId:node]) {
    [((JavaUtilArrayList *) nil_chk(mParents_)) addWithId:node];
    [((ADAnimatorSet_Node *) nil_chk(node)) addChildWithADAnimatorSet_Node:self];
  }
}

- (void)addParentsWithJavaUtilArrayList:(JavaUtilArrayList *)parents {
  if (parents == nil) {
    return;
  }
  int32_t size = [parents size];
  for (int32_t i = 0; i < size; i++) {
    [self addParentWithADAnimatorSet_Node:[parents getWithInt:i]];
  }
}

- (void)dealloc {
  RELEASE_(mAnimation_);
  RELEASE_(mChildNodes_);
  RELEASE_(mSiblings_);
  RELEASE_(mParents_);
  RELEASE_(mLatestParent_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LADAnimatorSet_Node;", 0x1, 1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 5, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, 8, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADAnimator:);
  methods[1].selector = @selector(java_clone);
  methods[2].selector = @selector(addChildWithADAnimatorSet_Node:);
  methods[3].selector = @selector(addSiblingWithADAnimatorSet_Node:);
  methods[4].selector = @selector(addParentWithADAnimatorSet_Node:);
  methods[5].selector = @selector(addParentsWithJavaUtilArrayList:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mAnimation_", "LADAnimator;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mChildNodes_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x0, -1, -1, 9, -1 },
    { "mEnded_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mSiblings_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x0, -1, -1, 9, -1 },
    { "mParents_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x0, -1, -1, 9, -1 },
    { "mLatestParent_", "LADAnimatorSet_Node;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mParentsAdded_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mStartTime_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mEndTime_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mTotalDuration_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADAnimator;", "clone", "addChild", "LADAnimatorSet_Node;", "addSibling", "addParent", "addParents", "LJavaUtilArrayList;", "(Ljava/util/ArrayList<Lr/android/animation/AnimatorSet$Node;>;)V", "Ljava/util/ArrayList<Lr/android/animation/AnimatorSet$Node;>;", "LADAnimatorSet;" };
  static const J2ObjcClassInfo _ADAnimatorSet_Node = { "Node", "r.android.animation", ptrTable, methods, fields, 7, 0xa, 6, 10, 10, -1, -1, -1, -1 };
  return &_ADAnimatorSet_Node;
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self java_clone] retain];
}

@end

void ADAnimatorSet_Node_initWithADAnimator_(ADAnimatorSet_Node *self, ADAnimator *animation) {
  NSObject_init(self);
  JreStrongAssign(&self->mChildNodes_, nil);
  self->mEnded_ = false;
  JreStrongAssign(&self->mLatestParent_, nil);
  self->mParentsAdded_ = false;
  self->mStartTime_ = 0;
  self->mEndTime_ = 0;
  self->mTotalDuration_ = 0;
  JreStrongAssign(&self->mAnimation_, animation);
}

ADAnimatorSet_Node *new_ADAnimatorSet_Node_initWithADAnimator_(ADAnimator *animation) {
  J2OBJC_NEW_IMPL(ADAnimatorSet_Node, initWithADAnimator_, animation)
}

ADAnimatorSet_Node *create_ADAnimatorSet_Node_initWithADAnimator_(ADAnimator *animation) {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_Node, initWithADAnimator_, animation)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADAnimatorSet_Node)

@implementation ADAnimatorSet_AnimationEvent

- (instancetype)initWithADAnimatorSet_Node:(ADAnimatorSet_Node *)node
                                   withInt:(int32_t)event {
  ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(self, node, event);
  return self;
}

- (int64_t)getTime {
  if (mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_START) {
    return ((ADAnimatorSet_Node *) nil_chk(mNode_))->mStartTime_;
  }
  else if (mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED) {
    return ((ADAnimatorSet_Node *) nil_chk(mNode_))->mStartTime_ == ADAnimator_DURATION_INFINITE ? ADAnimator_DURATION_INFINITE : mNode_->mStartTime_ + [((ADAnimator *) nil_chk(mNode_->mAnimation_)) getStartDelay];
  }
  else {
    return ((ADAnimatorSet_Node *) nil_chk(mNode_))->mEndTime_;
  }
}

- (NSString *)description {
  NSString *eventStr = mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_START ? @"start" : (mEvent_ == ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED ? @"delay ended" : @"end");
  return JreStrcat("$C$", eventStr, ' ', [((ADAnimator *) nil_chk(((ADAnimatorSet_Node *) nil_chk(mNode_))->mAnimation_)) description]);
}

- (void)dealloc {
  RELEASE_(mNode_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "J", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADAnimatorSet_Node:withInt:);
  methods[1].selector = @selector(getTime);
  methods[2].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "ANIMATION_START", "I", .constantValue.asInt = ADAnimatorSet_AnimationEvent_ANIMATION_START, 0x18, -1, -1, -1, -1 },
    { "ANIMATION_DELAY_ENDED", "I", .constantValue.asInt = ADAnimatorSet_AnimationEvent_ANIMATION_DELAY_ENDED, 0x18, -1, -1, -1, -1 },
    { "ANIMATION_END", "I", .constantValue.asInt = ADAnimatorSet_AnimationEvent_ANIMATION_END, 0x18, -1, -1, -1, -1 },
    { "mNode_", "LADAnimatorSet_Node;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "mEvent_", "I", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADAnimatorSet_Node;I", "toString", "LADAnimatorSet;" };
  static const J2ObjcClassInfo _ADAnimatorSet_AnimationEvent = { "AnimationEvent", "r.android.animation", ptrTable, methods, fields, 7, 0xa, 3, 5, 2, -1, -1, -1, -1 };
  return &_ADAnimatorSet_AnimationEvent;
}

@end

void ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(ADAnimatorSet_AnimationEvent *self, ADAnimatorSet_Node *node, int32_t event) {
  NSObject_init(self);
  JreStrongAssign(&self->mNode_, node);
  self->mEvent_ = event;
}

ADAnimatorSet_AnimationEvent *new_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(ADAnimatorSet_Node *node, int32_t event) {
  J2OBJC_NEW_IMPL(ADAnimatorSet_AnimationEvent, initWithADAnimatorSet_Node_withInt_, node, event)
}

ADAnimatorSet_AnimationEvent *create_ADAnimatorSet_AnimationEvent_initWithADAnimatorSet_Node_withInt_(ADAnimatorSet_Node *node, int32_t event) {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_AnimationEvent, initWithADAnimatorSet_Node_withInt_, node, event)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADAnimatorSet_AnimationEvent)

@implementation ADAnimatorSet_SeekState

- (instancetype)initWithADAnimatorSet:(ADAnimatorSet *)outer$ {
  ADAnimatorSet_SeekState_initWithADAnimatorSet_(self, outer$);
  return self;
}

- (void)reset {
  mPlayTime_ = -1;
  mSeekingInReverse_ = false;
}

- (void)setPlayTimeWithLong:(int64_t)playTime
                withBoolean:(bool)inReverse {
  if ([this$0_ getTotalDuration] != ADAnimator_DURATION_INFINITE) {
    mPlayTime_ = JavaLangMath_minWithLong_withLong_(playTime, [this$0_ getTotalDuration] - this$0_->mStartDelay_);
  }
  else {
    mPlayTime_ = playTime;
  }
  mPlayTime_ = JavaLangMath_maxWithLong_withLong_(0, mPlayTime_);
  mSeekingInReverse_ = inReverse;
}

- (void)updateSeekDirectionWithBoolean:(bool)inReverse {
  if (inReverse && [this$0_ getTotalDuration] == ADAnimator_DURATION_INFINITE) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Error: Cannot reverse infinite animator set");
  }
  if (mPlayTime_ >= 0) {
    if (inReverse != mSeekingInReverse_) {
      mPlayTime_ = [this$0_ getTotalDuration] - this$0_->mStartDelay_ - mPlayTime_;
      mSeekingInReverse_ = inReverse;
    }
  }
}

- (int64_t)getPlayTime {
  return mPlayTime_;
}

- (int64_t)getPlayTimeNormalized {
  if (this$0_->mReversing_) {
    return [this$0_ getTotalDuration] - this$0_->mStartDelay_ - mPlayTime_;
  }
  return mPlayTime_;
}

- (bool)isActive {
  return mPlayTime_ != -1;
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 3, 4, -1, -1, -1, -1 },
    { NULL, "J", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADAnimatorSet:);
  methods[1].selector = @selector(reset);
  methods[2].selector = @selector(setPlayTimeWithLong:withBoolean:);
  methods[3].selector = @selector(updateSeekDirectionWithBoolean:);
  methods[4].selector = @selector(getPlayTime);
  methods[5].selector = @selector(getPlayTimeNormalized);
  methods[6].selector = @selector(isActive);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LADAnimatorSet;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "mPlayTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mSeekingInReverse_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADAnimatorSet;", "setPlayTime", "JZ", "updateSeekDirection", "Z" };
  static const J2ObjcClassInfo _ADAnimatorSet_SeekState = { "SeekState", "r.android.animation", ptrTable, methods, fields, 7, 0x2, 7, 3, 0, -1, -1, -1, -1 };
  return &_ADAnimatorSet_SeekState;
}

@end

void ADAnimatorSet_SeekState_initWithADAnimatorSet_(ADAnimatorSet_SeekState *self, ADAnimatorSet *outer$) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
  self->mPlayTime_ = -1;
  self->mSeekingInReverse_ = false;
}

ADAnimatorSet_SeekState *new_ADAnimatorSet_SeekState_initWithADAnimatorSet_(ADAnimatorSet *outer$) {
  J2OBJC_NEW_IMPL(ADAnimatorSet_SeekState, initWithADAnimatorSet_, outer$)
}

ADAnimatorSet_SeekState *create_ADAnimatorSet_SeekState_initWithADAnimatorSet_(ADAnimatorSet *outer$) {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_SeekState, initWithADAnimatorSet_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADAnimatorSet_SeekState)

@implementation ADAnimatorSet_Builder

- (instancetype)initWithADAnimatorSet:(ADAnimatorSet *)outer$
                       withADAnimator:(ADAnimator *)anim {
  ADAnimatorSet_Builder_initWithADAnimatorSet_withADAnimator_(self, outer$, anim);
  return self;
}

- (ADAnimatorSet_Builder *)withWithADAnimator:(ADAnimator *)anim {
  ADAnimatorSet_Node *node = ADAnimatorSet_getNodeForAnimationWithADAnimator_(this$0_, anim);
  [((ADAnimatorSet_Node *) nil_chk(mCurrentNode_)) addSiblingWithADAnimatorSet_Node:node];
  return self;
}

- (ADAnimatorSet_Builder *)beforeWithADAnimator:(ADAnimator *)anim {
  ADAnimatorSet_Node *node = ADAnimatorSet_getNodeForAnimationWithADAnimator_(this$0_, anim);
  [((ADAnimatorSet_Node *) nil_chk(mCurrentNode_)) addChildWithADAnimatorSet_Node:node];
  return self;
}

- (ADAnimatorSet_Builder *)afterWithADAnimator:(ADAnimator *)anim {
  ADAnimatorSet_Node *node = ADAnimatorSet_getNodeForAnimationWithADAnimator_(this$0_, anim);
  [((ADAnimatorSet_Node *) nil_chk(mCurrentNode_)) addParentWithADAnimatorSet_Node:node];
  return self;
}

- (ADAnimatorSet_Builder *)afterWithLong:(int64_t)delay {
  ADValueAnimator *anim = ADValueAnimator_ofFloatWithFloatArray_([IOSFloatArray arrayWithFloats:(float[]){ 0.0f, 1.0f } count:2]);
  [((ADValueAnimator *) nil_chk(anim)) setDurationWithLong:delay];
  [self afterWithADAnimator:anim];
  return self;
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(mCurrentNode_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LADAnimatorSet_Builder;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LADAnimatorSet_Builder;", 0x1, 3, 2, -1, -1, -1, -1 },
    { NULL, "LADAnimatorSet_Builder;", 0x1, 4, 2, -1, -1, -1, -1 },
    { NULL, "LADAnimatorSet_Builder;", 0x1, 4, 5, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithADAnimatorSet:withADAnimator:);
  methods[1].selector = @selector(withWithADAnimator:);
  methods[2].selector = @selector(beforeWithADAnimator:);
  methods[3].selector = @selector(afterWithADAnimator:);
  methods[4].selector = @selector(afterWithLong:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LADAnimatorSet;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "mCurrentNode_", "LADAnimatorSet_Node;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LADAnimatorSet;LADAnimator;", "with", "LADAnimator;", "before", "after", "J", "LADAnimatorSet;" };
  static const J2ObjcClassInfo _ADAnimatorSet_Builder = { "Builder", "r.android.animation", ptrTable, methods, fields, 7, 0x1, 5, 2, 6, -1, -1, -1, -1 };
  return &_ADAnimatorSet_Builder;
}

@end

void ADAnimatorSet_Builder_initWithADAnimatorSet_withADAnimator_(ADAnimatorSet_Builder *self, ADAnimatorSet *outer$, ADAnimator *anim) {
  JreStrongAssign(&self->this$0_, outer$);
  NSObject_init(self);
  outer$->mDependencyDirty_ = true;
  JreStrongAssign(&self->mCurrentNode_, ADAnimatorSet_getNodeForAnimationWithADAnimator_(outer$, anim));
}

ADAnimatorSet_Builder *new_ADAnimatorSet_Builder_initWithADAnimatorSet_withADAnimator_(ADAnimatorSet *outer$, ADAnimator *anim) {
  J2OBJC_NEW_IMPL(ADAnimatorSet_Builder, initWithADAnimatorSet_withADAnimator_, outer$, anim)
}

ADAnimatorSet_Builder *create_ADAnimatorSet_Builder_initWithADAnimatorSet_withADAnimator_(ADAnimatorSet *outer$, ADAnimator *anim) {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_Builder, initWithADAnimatorSet_withADAnimator_, outer$, anim)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADAnimatorSet_Builder)

J2OBJC_INITIALIZED_DEFN(ADAnimatorSet_$Lambda$1)

@implementation ADAnimatorSet_$Lambda$1

- (void)acceptWithId:(ADAnimator *)a {
  [((ADAnimator *) nil_chk(a)) cancel];
}

- (id<JavaUtilFunctionConsumer>)andThenWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)arg0 {
  return JavaUtilFunctionConsumer_andThenWithJavaUtilFunctionConsumer_(self, arg0);
}

+ (void)initialize {
  if (self == [ADAnimatorSet_$Lambda$1 class]) {
    JreStrongAssignAndConsume(&ADAnimatorSet_$Lambda$1_instance, new_ADAnimatorSet_$Lambda$1_init());
    J2OBJC_SET_INITIALIZED(ADAnimatorSet_$Lambda$1)
  }
}

@end

void ADAnimatorSet_$Lambda$1_init(ADAnimatorSet_$Lambda$1 *self) {
  NSObject_init(self);
}

ADAnimatorSet_$Lambda$1 *new_ADAnimatorSet_$Lambda$1_init() {
  J2OBJC_NEW_IMPL(ADAnimatorSet_$Lambda$1, init)
}

ADAnimatorSet_$Lambda$1 *create_ADAnimatorSet_$Lambda$1_init() {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_$Lambda$1, init)
}

J2OBJC_INITIALIZED_DEFN(ADAnimatorSet_$Lambda$2)

@implementation ADAnimatorSet_$Lambda$2

- (void)acceptWithId:(ADAnimator *)a {
  [((ADAnimator *) nil_chk(a)) pause];
}

- (id<JavaUtilFunctionConsumer>)andThenWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)arg0 {
  return JavaUtilFunctionConsumer_andThenWithJavaUtilFunctionConsumer_(self, arg0);
}

+ (void)initialize {
  if (self == [ADAnimatorSet_$Lambda$2 class]) {
    JreStrongAssignAndConsume(&ADAnimatorSet_$Lambda$2_instance, new_ADAnimatorSet_$Lambda$2_init());
    J2OBJC_SET_INITIALIZED(ADAnimatorSet_$Lambda$2)
  }
}

@end

void ADAnimatorSet_$Lambda$2_init(ADAnimatorSet_$Lambda$2 *self) {
  NSObject_init(self);
}

ADAnimatorSet_$Lambda$2 *new_ADAnimatorSet_$Lambda$2_init() {
  J2OBJC_NEW_IMPL(ADAnimatorSet_$Lambda$2, init)
}

ADAnimatorSet_$Lambda$2 *create_ADAnimatorSet_$Lambda$2_init() {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_$Lambda$2, init)
}

J2OBJC_INITIALIZED_DEFN(ADAnimatorSet_$Lambda$3)

@implementation ADAnimatorSet_$Lambda$3

- (void)acceptWithId:(ADAnimator *)a {
  [((ADAnimator *) nil_chk(a)) resume];
}

- (id<JavaUtilFunctionConsumer>)andThenWithJavaUtilFunctionConsumer:(id<JavaUtilFunctionConsumer>)arg0 {
  return JavaUtilFunctionConsumer_andThenWithJavaUtilFunctionConsumer_(self, arg0);
}

+ (void)initialize {
  if (self == [ADAnimatorSet_$Lambda$3 class]) {
    JreStrongAssignAndConsume(&ADAnimatorSet_$Lambda$3_instance, new_ADAnimatorSet_$Lambda$3_init());
    J2OBJC_SET_INITIALIZED(ADAnimatorSet_$Lambda$3)
  }
}

@end

void ADAnimatorSet_$Lambda$3_init(ADAnimatorSet_$Lambda$3 *self) {
  NSObject_init(self);
}

ADAnimatorSet_$Lambda$3 *new_ADAnimatorSet_$Lambda$3_init() {
  J2OBJC_NEW_IMPL(ADAnimatorSet_$Lambda$3, init)
}

ADAnimatorSet_$Lambda$3 *create_ADAnimatorSet_$Lambda$3_init() {
  J2OBJC_CREATE_IMPL(ADAnimatorSet_$Lambda$3, init)
}
