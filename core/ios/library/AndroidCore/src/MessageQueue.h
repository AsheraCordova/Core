//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroid\src\main\java\r\android\os\MessageQueue.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_MessageQueue")
#ifdef RESTRICT_MessageQueue
#define INCLUDE_ALL_MessageQueue 0
#else
#define INCLUDE_ALL_MessageQueue 1
#endif
#undef RESTRICT_MessageQueue

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ADMessageQueue_) && (INCLUDE_ALL_MessageQueue || defined(INCLUDE_ADMessageQueue))
#define ADMessageQueue_

@class ADHandler;
@class ADMessage;
@protocol ADMessageQueue_IdleHandler;
@protocol JavaLangRunnable;

/*!
 @brief Low-level class holding the list of messages to be dispatched by a 
 <code>Looper</code>.Messages are not added directly to a MessageQueue,
  but rather through <code>Handler</code> objects associated with the Looper.
 <p>You can retrieve the MessageQueue for the current thread with 
 <code>Looper.myQueue()</code>.
 */
@interface ADMessageQueue : NSObject {
 @public
  ADMessage *mMessages_;
}

#pragma mark Public

/*!
 @brief Add a new <code>IdleHandler</code> to this message queue.This may be
  removed automatically for you by returning false from 
 <code>IdleHandler.queueIdle()</code> when it is
  invoked, or explicitly removing it with <code>removeIdleHandler</code>.
 <p>This method is safe to call from any thread.
 @param handler The IdleHandler to be added.
 */
- (void)addIdleHandlerWithADMessageQueue_IdleHandler:(id<ADMessageQueue_IdleHandler>)handler;

/*!
 @brief Returns true if the looper has no pending messages which are due to be processed.
 <p>This method is safe to call from any thread.
 @return True if the looper is idle.
 */
- (jboolean)isIdle;

/*!
 @brief Returns whether this looper's thread is currently polling for more work to do.
 This is a good signal that the loop is still alive rather than being stuck
  handling a callback.  Note that this method is intrinsically racy, since the
  state of the loop can change before you get the result back. 
 <p>This method is safe to call from any thread.
 @return True if the looper is currently polling for events.
 */
- (jboolean)isPolling;

/*!
 @brief Remove an <code>IdleHandler</code> from the queue that was previously added
  with <code>addIdleHandler</code>.If the given object is not currently
  in the idle list, nothing is done.
 <p>This method is safe to call from any thread.
 @param handler The IdleHandler to be removed.
 */
- (void)removeIdleHandlerWithADMessageQueue_IdleHandler:(id<ADMessageQueue_IdleHandler>)handler;

#pragma mark Protected

- (void)java_finalize;

#pragma mark Package-Private

- (instancetype)initWithBoolean:(jboolean)quitAllowed;

/*!
 @brief Posts a synchronization barrier to the Looper's message queue.
 Message processing occurs as usual until the message queue encounters the
  synchronization barrier that has been posted.  When the barrier is encountered,
  later synchronous messages in the queue are stalled (prevented from being executed)
  until the barrier is released by calling <code>removeSyncBarrier</code> and specifying
  the token that identifies the synchronization barrier.
  This method is used to immediately postpone execution of all subsequently posted
  synchronous messages until a condition is met that releases the barrier.
  Asynchronous messages (see <code>Message.isAsynchronous</code> are exempt from the barrier
  and continue to be processed as usual.
  This call must be always matched by a call to <code>removeSyncBarrier</code> with
  the same token to ensure that the message queue resumes normal operation.
  Otherwise the application will probably hang!
 @return A token that uniquely identifies the barrier.  This token must be
  passed to <code>removeSyncBarrier</code> to release the barrier.
 */
- (jboolean)enqueueMessageWithADMessage:(ADMessage *)msg
                               withLong:(jlong)when;

- (jboolean)hasEqualMessagesWithADHandler:(ADHandler *)h
                                  withInt:(jint)what
                                   withId:(id)object;

- (jboolean)hasMessagesWithADHandler:(ADHandler *)h;

- (jboolean)hasMessagesWithADHandler:(ADHandler *)h
                             withInt:(jint)what
                              withId:(id)object;

- (jboolean)hasMessagesWithADHandler:(ADHandler *)h
                withJavaLangRunnable:(id<JavaLangRunnable>)r
                              withId:(id)object;

- (void)quitWithBoolean:(jboolean)safe;

- (void)removeCallbacksAndEqualMessagesWithADHandler:(ADHandler *)h
                                              withId:(id)object;

- (void)removeCallbacksAndMessagesWithADHandler:(ADHandler *)h
                                         withId:(id)object;

- (void)removeEqualMessagesWithADHandler:(ADHandler *)h
                                 withInt:(jint)what
                                  withId:(id)object;

- (void)removeEqualMessagesWithADHandler:(ADHandler *)h
                    withJavaLangRunnable:(id<JavaLangRunnable>)r
                                  withId:(id)object;

- (void)removeMessagesWithADHandler:(ADHandler *)h
                            withInt:(jint)what
                             withId:(id)object;

- (void)removeMessagesWithADHandler:(ADHandler *)h
               withJavaLangRunnable:(id<JavaLangRunnable>)r
                             withId:(id)object;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ADMessageQueue)

J2OBJC_FIELD_SETTER(ADMessageQueue, mMessages_, ADMessage *)

FOUNDATION_EXPORT void ADMessageQueue_initWithBoolean_(ADMessageQueue *self, jboolean quitAllowed);

FOUNDATION_EXPORT ADMessageQueue *new_ADMessageQueue_initWithBoolean_(jboolean quitAllowed) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ADMessageQueue *create_ADMessageQueue_initWithBoolean_(jboolean quitAllowed);

J2OBJC_TYPE_LITERAL_HEADER(ADMessageQueue)

@compatibility_alias RAndroidOsMessageQueue ADMessageQueue;

#endif

#if !defined (ADMessageQueue_IdleHandler_) && (INCLUDE_ALL_MessageQueue || defined(INCLUDE_ADMessageQueue_IdleHandler))
#define ADMessageQueue_IdleHandler_

/*!
 @brief Callback interface for discovering when a thread is going to block
  waiting for more messages.
 */
@protocol ADMessageQueue_IdleHandler < JavaObject >

/*!
 @brief Called when the message queue has run out of messages and will now
  wait for more.Return true to keep your idle handler active, false
  to have it removed.
 This may be called if there are still messages
  pending in the queue, but they are all scheduled to be dispatched
  after the current time.
 */
- (jboolean)queueIdle;

@end

J2OBJC_EMPTY_STATIC_INIT(ADMessageQueue_IdleHandler)

J2OBJC_TYPE_LITERAL_HEADER(ADMessageQueue_IdleHandler)

#endif

#if !defined (ADMessageQueue_OnFileDescriptorEventListener_) && (INCLUDE_ALL_MessageQueue || defined(INCLUDE_ADMessageQueue_OnFileDescriptorEventListener))
#define ADMessageQueue_OnFileDescriptorEventListener_

@class JavaIoFileDescriptor;

/*!
 @brief A listener which is invoked when file descriptor related events occur.
 */
@protocol ADMessageQueue_OnFileDescriptorEventListener < JavaObject >

/*!
 @brief Called when a file descriptor receives events.
 @param fd The file descriptor.
 @param events The set of events that occurred: a combination of the  
 <code>EVENT_INPUT</code> , <code>EVENT_OUTPUT</code> , and <code>EVENT_ERROR</code>  event masks.
 @return The new set of events to watch, or 0 to unregister the listener.
 - seealso: #EVENT_INPUT
 - seealso: #EVENT_OUTPUT
 - seealso: #EVENT_ERROR
 */
- (jint)onFileDescriptorEventsWithJavaIoFileDescriptor:(JavaIoFileDescriptor *)fd
                                               withInt:(jint)events;

@end

J2OBJC_EMPTY_STATIC_INIT(ADMessageQueue_OnFileDescriptorEventListener)

/*!
 @brief File descriptor event: Indicates that the file descriptor is ready for input
  operations, such as reading.
 <p>
  The listener should read all available data from the file descriptor
  then return <code>true</code> to keep the listener active or <code>false</code>
  to remove the listener. 
 </p><p>
  In the case of a socket, this event may be generated to indicate
  that there is at least one incoming connection that the listener
  should accept. 
 </p><p>
  This event will only be generated if the <code>EVENT_INPUT</code> event mask was
  specified when the listener was added. 
 </p>
 */
inline jint ADMessageQueue_OnFileDescriptorEventListener_get_EVENT_INPUT(void);
#define ADMessageQueue_OnFileDescriptorEventListener_EVENT_INPUT 1
J2OBJC_STATIC_FIELD_CONSTANT(ADMessageQueue_OnFileDescriptorEventListener, EVENT_INPUT, jint)

/*!
 @brief File descriptor event: Indicates that the file descriptor is ready for output
  operations, such as writing.
 <p>
  The listener should write as much data as it needs.  If it could not
  write everything at once, then it should return <code>true</code> to
  keep the listener active.  Otherwise, it should return <code>false</code>
  to remove the listener then re-register it later when it needs to write
  something else. 
 </p><p>
  This event will only be generated if the <code>EVENT_OUTPUT</code> event mask was
  specified when the listener was added. 
 </p>
 */
inline jint ADMessageQueue_OnFileDescriptorEventListener_get_EVENT_OUTPUT(void);
#define ADMessageQueue_OnFileDescriptorEventListener_EVENT_OUTPUT 2
J2OBJC_STATIC_FIELD_CONSTANT(ADMessageQueue_OnFileDescriptorEventListener, EVENT_OUTPUT, jint)

/*!
 @brief File descriptor event: Indicates that the file descriptor encountered a
  fatal error.
 <p>
  File descriptor errors can occur for various reasons.  One common error
  is when the remote peer of a socket or pipe closes its end of the connection. 
 </p><p>
  This event may be generated at any time regardless of whether the 
 <code>EVENT_ERROR</code> event mask was specified when the listener was added. 
 </p>
 */
inline jint ADMessageQueue_OnFileDescriptorEventListener_get_EVENT_ERROR(void);
#define ADMessageQueue_OnFileDescriptorEventListener_EVENT_ERROR 4
J2OBJC_STATIC_FIELD_CONSTANT(ADMessageQueue_OnFileDescriptorEventListener, EVENT_ERROR, jint)

J2OBJC_TYPE_LITERAL_HEADER(ADMessageQueue_OnFileDescriptorEventListener)

#endif

#if !defined (ADMessageQueue_OnFileDescriptorEventListener_Events_) && (INCLUDE_ALL_MessageQueue || defined(INCLUDE_ADMessageQueue_OnFileDescriptorEventListener_Events))
#define ADMessageQueue_OnFileDescriptorEventListener_Events_

#define RESTRICT_JavaLangAnnotationAnnotation 1
#define INCLUDE_JavaLangAnnotationAnnotation 1
#include "java/lang/annotation/Annotation.h"

/*!
 */
@protocol ADMessageQueue_OnFileDescriptorEventListener_Events < JavaLangAnnotationAnnotation >

@end

J2OBJC_EMPTY_STATIC_INIT(ADMessageQueue_OnFileDescriptorEventListener_Events)

J2OBJC_TYPE_LITERAL_HEADER(ADMessageQueue_OnFileDescriptorEventListener_Events)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_MessageQueue")
