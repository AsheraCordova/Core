//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroid\src\main\java\com\ashera\view\BaseMeasurableImageView.java
//

#define J2OBJC_IMPORTED_BY_JAVA_IMPLEMENTATION 1




#include "BaseMeasurableImageView.h"
#include "Drawable.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "IWidget.h"
#include "IsImage.h"
#include "J2ObjC_source.h"
#include "RectM.h"
#include "View.h"
#include "java/lang/Boolean.h"
#include "java/lang/Float.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"


@class NSString;


#pragma clang diagnostic error "-Wreturn-type"
#pragma clang diagnostic ignored "-Wswitch"


@interface ASBaseMeasurableImageView () {
 @public
  WEAK_ id<ASIWidget> widget_;
  bool mAdjustViewBoundsCompat_;
  bool mAdjustViewBounds_;
  id mDrawable_;
  int32_t mDrawableWidth_;
  int32_t mDrawableHeight_;
  int32_t mMaxWidth_;
  int32_t mMaxHeight_;
  int32_t mBaseline_;
  bool mBaselineAlignBottom_;
  bool cropToPadding_;
  bool usePaddingForBounds_;
  NSString *scaleType_;
  int32_t scaleTypeInt_;
  ADDrawable *imageDrawable_;
}

- (void)resolveUri;

- (void)updateDrawable;

- (int32_t)resolveAdjustedSizeWithInt:(int32_t)desiredSize
                              withInt:(int32_t)maxSize
                              withInt:(int32_t)measureSpec;

@end

J2OBJC_FIELD_SETTER(ASBaseMeasurableImageView, mDrawable_, id)
J2OBJC_FIELD_SETTER(ASBaseMeasurableImageView, scaleType_, NSString *)
J2OBJC_FIELD_SETTER(ASBaseMeasurableImageView, imageDrawable_, ADDrawable *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_FITXY(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_FITXY = @"fitXY";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_FITXY, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_CENTERINSIDE(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_CENTERINSIDE = @"centerInside";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_CENTERINSIDE, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_CENTER(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_CENTER = @"center";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_CENTER, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_CENTERCROP(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_CENTERCROP = @"centerCrop";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_CENTERCROP, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_FITEND(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_FITEND = @"fitEnd";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_FITEND, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_FITSTART(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_FITSTART = @"fitStart";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_FITSTART, NSString *)

inline NSString *ASBaseMeasurableImageView_get_SCALETYPE_FITCENTER(void);
static NSString *ASBaseMeasurableImageView_SCALETYPE_FITCENTER = @"fitCenter";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ASBaseMeasurableImageView, SCALETYPE_FITCENTER, NSString *)

__attribute__((unused)) static void ASBaseMeasurableImageView_resolveUri(ASBaseMeasurableImageView *self);

__attribute__((unused)) static void ASBaseMeasurableImageView_updateDrawable(ASBaseMeasurableImageView *self);

__attribute__((unused)) static int32_t ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(ASBaseMeasurableImageView *self, int32_t desiredSize, int32_t maxSize, int32_t measureSpec);

@implementation ASBaseMeasurableImageView

- (int32_t)getScaleTypeInt {
  return scaleTypeInt_;
}

- (NSString *)getScaleType {
  return scaleType_;
}

- (void)setScaleTypeWithNSString:(NSString *)scaleType
                         withInt:(int32_t)scaleTypeInt {
  JreStrongAssign(&self->scaleType_, scaleType);
  self->scaleTypeInt_ = scaleTypeInt;
}

- (void)setUsePaddingForBoundsWithBoolean:(bool)usePaddingForBounds {
  self->usePaddingForBounds_ = usePaddingForBounds;
}

- (void)setCropToPaddingWithBoolean:(bool)objValue {
  self->cropToPadding_ = objValue;
}

- (bool)getCropToPadding {
  return cropToPadding_;
}

- (instancetype)initWithASIWidget:(id<ASIWidget>)widget {
  ASBaseMeasurableImageView_initWithASIWidget_(self, widget);
  return self;
}

- (id<ASIWidget>)getWidget {
  return widget_;
}

- (void)onMeasureWithInt:(int32_t)widthMeasureSpec
                 withInt:(int32_t)heightMeasureSpec {
  ASBaseMeasurableImageView_resolveUri(self);
  int32_t w;
  int32_t h;
  float desiredAspect = 0.0f;
  bool resizeWidth = false;
  bool resizeHeight = false;
  int32_t widthSpecMode = ADView_MeasureSpec_getModeWithInt_(widthMeasureSpec);
  int32_t heightSpecMode = ADView_MeasureSpec_getModeWithInt_(heightMeasureSpec);
  if (mDrawable_ == nil) {
    mDrawableWidth_ = -1;
    mDrawableHeight_ = -1;
    w = h = 0;
  }
  else {
    w = mDrawableWidth_;
    h = mDrawableHeight_;
    if (w <= 0) w = 1;
    if (h <= 0) h = 1;
    if (mAdjustViewBounds_) {
      resizeWidth = (widthSpecMode != ADView_MeasureSpec_EXACTLY);
      resizeHeight = (heightSpecMode != ADView_MeasureSpec_EXACTLY);
      desiredAspect = (float) w / (float) h;
    }
  }
  int32_t pleft = mPaddingLeft_;
  int32_t pright = mPaddingRight_;
  int32_t ptop = mPaddingTop_;
  int32_t pbottom = mPaddingBottom_;
  int32_t widthSize;
  int32_t heightSize;
  if (resizeWidth || resizeHeight) {
    widthSize = ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, w + pleft + pright, mMaxWidth_, widthMeasureSpec);
    heightSize = ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, h + ptop + pbottom, mMaxHeight_, heightMeasureSpec);
    if (desiredAspect != 0.0f) {
      float actualAspect = (float) (widthSize - pleft - pright) / (heightSize - ptop - pbottom);
      if (JavaLangMath_absWithFloat_(actualAspect - desiredAspect) > 0.0000001) {
        bool done = false;
        if (resizeWidth) {
          int32_t newWidth = JreFpToInt((desiredAspect * (heightSize - ptop - pbottom))) + pleft + pright;
          if (!resizeHeight && !mAdjustViewBoundsCompat_) {
            widthSize = ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, newWidth, mMaxWidth_, widthMeasureSpec);
          }
          if (newWidth <= widthSize) {
            widthSize = newWidth;
            done = true;
          }
        }
        if (!done && resizeHeight) {
          int32_t newHeight = JreFpToInt(((widthSize - pleft - pright) / desiredAspect)) + ptop + pbottom;
          if (!resizeWidth && !mAdjustViewBoundsCompat_) {
            heightSize = ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, newHeight, mMaxHeight_, heightMeasureSpec);
          }
          if (newHeight <= heightSize) {
            heightSize = newHeight;
          }
        }
      }
    }
  }
  else {
    w += pleft + pright;
    h += ptop + pbottom;
    w = JavaLangMath_maxWithInt_withInt_(w, [self getSuggestedMinimumWidth]);
    h = JavaLangMath_maxWithInt_withInt_(h, [self getSuggestedMinimumHeight]);
    widthSize = ADView_resolveSizeAndStateWithInt_withInt_withInt_(w, widthMeasureSpec, 0);
    heightSize = ADView_resolveSizeAndStateWithInt_withInt_withInt_(h, heightMeasureSpec, 0);
  }
  [self setMeasuredDimensionWithInt:widthSize withInt:heightSize];
}

- (void)resolveUri {
  ASBaseMeasurableImageView_resolveUri(self);
}

- (void)updateDrawable {
  ASBaseMeasurableImageView_updateDrawable(self);
}

- (int32_t)resolveAdjustedSizeWithInt:(int32_t)desiredSize
                              withInt:(int32_t)maxSize
                              withInt:(int32_t)measureSpec {
  return ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(self, desiredSize, maxSize, measureSpec);
}

- (void)setAdjustViewBoundsWithBoolean:(bool)mAdjustViewBounds {
  self->mAdjustViewBounds_ = mAdjustViewBounds;
}

- (bool)getAdjustViewBounds {
  return mAdjustViewBounds_;
}

- (int32_t)getMaxWidth {
  return mMaxWidth_;
}

- (int32_t)getMaxHeight {
  return mMaxHeight_;
}

- (void)setMaxWidthWithInt:(int32_t)mMaxWidth {
  self->mMaxWidth_ = mMaxWidth;
}

- (void)setMaxHeightWithInt:(int32_t)mMaxHeight {
  self->mMaxHeight_ = mMaxHeight;
}

- (int32_t)getBaseline {
  if (mBaselineAlignBottom_) {
    return [self getMeasuredHeight];
  }
  else {
    return mBaseline_;
  }
}

- (void)setBaselineWithInt:(int32_t)baseline {
  if (mBaseline_ != baseline) {
    mBaseline_ = baseline;
    [self requestLayout];
  }
}

- (void)setBaselineAlignBottomWithBoolean:(bool)aligned {
  if (mBaselineAlignBottom_ != aligned) {
    mBaselineAlignBottom_ = aligned;
    [self requestLayout];
  }
}

- (bool)getBaselineAlignBottom {
  return mBaselineAlignBottom_;
}

- (ASRectM *)getCropPaddingClipBounds {
  int32_t pLeft = 0;
  int32_t pTop = 0;
  int32_t pRight = 0;
  int32_t pBottom = 0;
  if (usePaddingForBounds_) {
    pLeft = [self getPaddingStart];
    pRight = [self getPaddingEnd];
    pTop = [self getPaddingTop];
    pBottom = [self getPaddingBottom];
  }
  int32_t vwidth = [self getMeasuredWidth] - pLeft - pRight;
  int32_t vheight = [self getMeasuredHeight] - pTop - pBottom;
  return create_ASRectM_initWithInt_withInt_withInt_withInt_(pLeft, pTop, vwidth, vheight);
}

- (ASRectM *)getImageBounds {
  int32_t measuredWidth = [self getMeasuredWidth];
  int32_t measuredHeight = [self getMeasuredHeight];
  return [self getImageBoundsWithInt:measuredWidth withInt:measuredHeight];
}

- (ASRectM *)getImageBoundsWithInt:(int32_t)measuredWidth
                           withInt:(int32_t)measuredHeight {
  if (mDrawableWidth_ == 0 && mDrawableHeight_ == 0) return nil;
  int32_t dwidth = mDrawableWidth_;
  int32_t dheight = mDrawableHeight_;
  int32_t pLeft = 0;
  int32_t pTop = 0;
  int32_t pRight = 0;
  int32_t pBottom = 0;
  if (usePaddingForBounds_) {
    pLeft = [self getPaddingStart];
    pRight = [self getPaddingEnd];
    pTop = [self getPaddingTop];
    pBottom = [self getPaddingBottom];
  }
  float dx = 0;
  float dy = 0;
  int32_t vwidth = measuredWidth - pLeft - pRight;
  int32_t vheight = measuredHeight - pTop - pBottom;
  int32_t newHeight = vheight;
  int32_t newWidth = vwidth;
  switch (JreIndexOfStr(scaleType_, (id[]){ ASBaseMeasurableImageView_SCALETYPE_FITXY, ASBaseMeasurableImageView_SCALETYPE_FITCENTER, ASBaseMeasurableImageView_SCALETYPE_FITSTART, ASBaseMeasurableImageView_SCALETYPE_FITEND, ASBaseMeasurableImageView_SCALETYPE_CENTERCROP, ASBaseMeasurableImageView_SCALETYPE_CENTER, ASBaseMeasurableImageView_SCALETYPE_CENTERINSIDE }, 7)) {
    case 0:
    {
      newWidth = vwidth;
      newHeight = vheight;
      break;
    }
    case 1:
    {
      newWidth = JreIntDiv((dwidth * vheight), dheight);
      newHeight = vheight;
      if (newWidth > vwidth) {
        newWidth = vwidth;
        newHeight = JreIntDiv((dheight * vwidth), dwidth);
      }
      dx = JavaLangMath_absWithInt_(newWidth - vwidth) * 0.5f;
      dy = JavaLangMath_absWithInt_(newHeight - vheight) * 0.5f;
      break;
    }
    case 2:
    {
      newWidth = JreIntDiv((dwidth * vheight), dheight);
      newHeight = vheight;
      if (newWidth > vwidth) {
        newWidth = vwidth;
        newHeight = JreIntDiv((dheight * vwidth), dwidth);
      }
      break;
    }
    case 3:
    {
      newWidth = JreIntDiv((dwidth * vheight), dheight);
      newHeight = vheight;
      if (newWidth > vwidth) {
        newWidth = vwidth;
        newHeight = JreIntDiv((dheight * vwidth), dwidth);
      }
      dx = JavaLangMath_absWithInt_(newWidth - vwidth);
      dy = JavaLangMath_absWithInt_(newHeight - vheight);
    }
    break;
    case 4:
    {
      float scale_;
      if (dwidth * vheight > vwidth * dheight) {
        scale_ = (float) vheight / (float) dheight;
        dx = (vwidth - dwidth * scale_) * 0.5f;
      }
      else {
        scale_ = (float) vwidth / (float) dwidth;
        dy = (vheight - dheight * scale_) * 0.5f;
      }
      newWidth = JreFpToInt((dwidth * scale_));
      newHeight = JreFpToInt((dheight * scale_));
      break;
    }
    case 5:
    {
      dx = JavaLangMath_roundWithFloat_((vwidth - dwidth) * 0.5f);
      dy = JavaLangMath_roundWithFloat_((vheight - dheight) * 0.5f);
      newWidth = dwidth;
      newHeight = dheight;
      break;
    }
    case 6:
    {
      float scale_;
      if (dwidth <= vwidth && dheight <= vheight) {
        scale_ = 1.0f;
      }
      else {
        scale_ = JavaLangMath_minWithFloat_withFloat_((float) vwidth / (float) dwidth, (float) vheight / (float) dheight);
      }
      dx = JavaLangMath_roundWithFloat_((vwidth - dwidth * scale_) * 0.5f);
      dy = JavaLangMath_roundWithFloat_((vheight - dheight * scale_) * 0.5f);
      newWidth = JreFpToInt((dwidth * scale_));
      newHeight = JreFpToInt((dheight * scale_));
      break;
    }
    default:
    break;
  }
  JrePlusAssignFloatF(&dx, pLeft);
  JrePlusAssignFloatF(&dy, pTop);
  return create_ASRectM_initWithInt_withInt_withInt_withInt_(JreFpToInt(dx), JreFpToInt(dy), newWidth, newHeight);
}

- (bool)hasDrawables {
  return false;
}

- (ADDrawable *)getImageDrawable {
  return imageDrawable_;
}

- (void)setImageDrawableWithADDrawable:(ADDrawable *)imageDrawable {
  JreStrongAssign(&self->imageDrawable_, imageDrawable);
}

- (void)__javaClone:(ASBaseMeasurableImageView *)original {
  [super __javaClone:original];
  [widget_ release];
}

- (void)dealloc {
  RELEASE_(mDrawable_);
  RELEASE_(scaleType_);
  RELEASE_(imageDrawable_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 5, -1, -1, -1, -1 },
    { NULL, "LASIWidget;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 12, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 14, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 15, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LASRectM;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LASRectM;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LASRectM;", 0x1, 16, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADDrawable;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 17, 18, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(getScaleTypeInt);
  methods[1].selector = @selector(getScaleType);
  methods[2].selector = @selector(setScaleTypeWithNSString:withInt:);
  methods[3].selector = @selector(setUsePaddingForBoundsWithBoolean:);
  methods[4].selector = @selector(setCropToPaddingWithBoolean:);
  methods[5].selector = @selector(getCropToPadding);
  methods[6].selector = @selector(initWithASIWidget:);
  methods[7].selector = @selector(getWidget);
  methods[8].selector = @selector(onMeasureWithInt:withInt:);
  methods[9].selector = @selector(resolveUri);
  methods[10].selector = @selector(updateDrawable);
  methods[11].selector = @selector(resolveAdjustedSizeWithInt:withInt:withInt:);
  methods[12].selector = @selector(setAdjustViewBoundsWithBoolean:);
  methods[13].selector = @selector(getAdjustViewBounds);
  methods[14].selector = @selector(getMaxWidth);
  methods[15].selector = @selector(getMaxHeight);
  methods[16].selector = @selector(setMaxWidthWithInt:);
  methods[17].selector = @selector(setMaxHeightWithInt:);
  methods[18].selector = @selector(getBaseline);
  methods[19].selector = @selector(setBaselineWithInt:);
  methods[20].selector = @selector(setBaselineAlignBottomWithBoolean:);
  methods[21].selector = @selector(getBaselineAlignBottom);
  methods[22].selector = @selector(getCropPaddingClipBounds);
  methods[23].selector = @selector(getImageBounds);
  methods[24].selector = @selector(getImageBoundsWithInt:withInt:);
  methods[25].selector = @selector(hasDrawables);
  methods[26].selector = @selector(getImageDrawable);
  methods[27].selector = @selector(setImageDrawableWithADDrawable:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "widget_", "LASIWidget;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAdjustViewBoundsCompat_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAdjustViewBounds_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDrawable_", "LNSObject;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDrawableWidth_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDrawableHeight_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mMaxWidth_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mMaxHeight_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mBaseline_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mBaselineAlignBottom_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "cropToPadding_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "usePaddingForBounds_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "scaleType_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "scaleTypeInt_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "SCALETYPE_FITXY", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 19, -1, -1 },
    { "SCALETYPE_CENTERINSIDE", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 20, -1, -1 },
    { "SCALETYPE_CENTER", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 21, -1, -1 },
    { "SCALETYPE_CENTERCROP", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 22, -1, -1 },
    { "SCALETYPE_FITEND", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 23, -1, -1 },
    { "SCALETYPE_FITSTART", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 24, -1, -1 },
    { "SCALETYPE_FITCENTER", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 25, -1, -1 },
    { "imageDrawable_", "LADDrawable;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "setScaleType", "LNSString;I", "setUsePaddingForBounds", "Z", "setCropToPadding", "LASIWidget;", "onMeasure", "II", "resolveAdjustedSize", "III", "setAdjustViewBounds", "setMaxWidth", "I", "setMaxHeight", "setBaseline", "setBaselineAlignBottom", "getImageBounds", "setImageDrawable", "LADDrawable;", &ASBaseMeasurableImageView_SCALETYPE_FITXY, &ASBaseMeasurableImageView_SCALETYPE_CENTERINSIDE, &ASBaseMeasurableImageView_SCALETYPE_CENTER, &ASBaseMeasurableImageView_SCALETYPE_CENTERCROP, &ASBaseMeasurableImageView_SCALETYPE_FITEND, &ASBaseMeasurableImageView_SCALETYPE_FITSTART, &ASBaseMeasurableImageView_SCALETYPE_FITCENTER };
  static const J2ObjcClassInfo _ASBaseMeasurableImageView = { "BaseMeasurableImageView", "com.ashera.view", ptrTable, methods, fields, 7, 0x401, 28, 22, -1, -1, -1, -1, -1 };
  return &_ASBaseMeasurableImageView;
}

@end

void ASBaseMeasurableImageView_initWithASIWidget_(ASBaseMeasurableImageView *self, id<ASIWidget> widget) {
  ADView_init(self);
  self->mAdjustViewBounds_ = false;
  self->mMaxWidth_ = JavaLangInteger_MAX_VALUE;
  self->mMaxHeight_ = JavaLangInteger_MAX_VALUE;
  self->mBaseline_ = -1;
  self->mBaselineAlignBottom_ = false;
  self->usePaddingForBounds_ = true;
  JreStrongAssign(&self->scaleType_, ASBaseMeasurableImageView_SCALETYPE_FITCENTER);
  self->widget_ = widget;
}

void ASBaseMeasurableImageView_resolveUri(ASBaseMeasurableImageView *self) {
  ASBaseMeasurableImageView_updateDrawable(self);
}

void ASBaseMeasurableImageView_updateDrawable(ASBaseMeasurableImageView *self) {
  id<ASIsImage> image = (id<ASIsImage>) cast_check(self->widget_, ASIsImage_class_());
  IOSIntArray *dimension = [((id<ASIsImage>) nil_chk(image)) getImageDimension];
  self->mDrawableWidth_ = (int32_t) IOSIntArray_Get(nil_chk(dimension), 0);
  self->mDrawableHeight_ = (int32_t) IOSIntArray_Get(dimension, 1);
  JreStrongAssign(&self->mDrawable_, [image getImage]);
}

int32_t ASBaseMeasurableImageView_resolveAdjustedSizeWithInt_withInt_withInt_(ASBaseMeasurableImageView *self, int32_t desiredSize, int32_t maxSize, int32_t measureSpec) {
  int32_t result = desiredSize;
  int32_t specMode = ADView_MeasureSpec_getModeWithInt_(measureSpec);
  int32_t specSize = ADView_MeasureSpec_getSizeWithInt_(measureSpec);
  switch (specMode) {
    case ADView_MeasureSpec_UNSPECIFIED:
    result = JavaLangMath_minWithInt_withInt_(desiredSize, maxSize);
    break;
    case ADView_MeasureSpec_AT_MOST:
    result = JavaLangMath_minWithInt_withInt_(JavaLangMath_minWithInt_withInt_(desiredSize, specSize), maxSize);
    break;
    case ADView_MeasureSpec_EXACTLY:
    result = specSize;
    break;
  }
  return result;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ASBaseMeasurableImageView)

J2OBJC_NAME_MAPPING(ASBaseMeasurableImageView, "com.ashera.view", "AS")
