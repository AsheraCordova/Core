//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: D:\Java\git\core-javafx-widget\SWTAndroid\src\main\java\r\android\animation\ValueAnimator.java
//

#define J2OBJC_IMPORTED_BY_JAVA_IMPLEMENTATION 1




#include "AccelerateDecelerateInterpolator.h"
#include "AndroidRuntimeException.h"
#include "AnimationHandler.h"
#include "AnimationUtils.h"
#include "Animator.h"
#include "ArgbEvaluator.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "LinearInterpolator.h"
#include "Log.h"
#include "Looper.h"
#include "PropertyValuesHolder.h"
#include "SystemProperties.h"
#include "TimeInterpolator.h"
#include "Trace.h"
#include "TypeEvaluator.h"
#include "ValueAnimator.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/lang/annotation/Annotation.h"
#include "java/lang/annotation/Retention.h"
#include "java/lang/annotation/RetentionPolicy.h"
#include "java/lang/ref/WeakReference.h"
#include "java/util/ArrayList.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"


@class NSString;


#pragma clang diagnostic error "-Wreturn-type"
#pragma clang diagnostic ignored "-Wswitch"


@interface ADValueAnimator () {
 @public
  /*!
   @brief Set on the next frame after pause() is called, used to calculate a new startTime
  or delayStartTime which allows the animator to continue from the point at which
  it was paused.If negative, has not yet been set.
   */
  int64_t mPauseTime_;
  /*!
   @brief Set when an animator is resumed.This triggers logic in the next frame which
  actually resumes the animator.
   */
  bool mResumed_;
  /*!
   @brief Flag to indicate whether this animator is playing in reverse mode, specifically
  by being started or interrupted by a call to reverse().This flag is different than
  mPlayingBackwards, which indicates merely whether the current iteration of the
  animator is playing in reverse.
   It is used in corner cases to determine proper end
  behavior.
   */
  bool mReversing_;
  /*!
   @brief Tracks the overall fraction of the animation, ranging from 0 to mRepeatCount + 1
   */
  float mOverallFraction_;
  /*!
   @brief Tracks current elapsed/eased fraction, for querying in getAnimatedFraction().
   This is calculated by interpolating the fraction (range: [0, 1]) in the current iteration.
   */
  float mCurrentFraction_;
  /*!
   @brief Tracks the time (in milliseconds) when the last frame arrived.
   */
  int64_t mLastFrameTime_;
  /*!
   @brief Tracks the time (in milliseconds) when the first frame arrived.Note the frame may arrive
  during the start delay.
   */
  int64_t mFirstFrameTime_;
  /*!
   @brief Additional playing state to indicate whether an animator has been start()'d.There is
  some lag between a call to start() and the first animation frame.
   We should still note
  that the animation has been started, even if it's first animation frame has not yet
  happened, and reflect that state in isRunning().
  Note that delayed animations are different: they are not started until their first
  animation frame, which occurs after their delay elapses.
   */
  bool mRunning_;
  /*!
   @brief Additional playing state to indicate whether an animator has been start()'d, whether or
  not there is a nonzero startDelay.
   */
  bool mStarted_;
  /*!
   @brief Flag that tracks whether animation has been requested to end.
   */
  bool mAnimationEndRequested_;
  int64_t mDuration_;
  int64_t mStartDelay_;
  int32_t mRepeatCount_;
  /*!
   @brief The type of repetition that will occur when repeatMode is nonzero.RESTART means the
  animation will start from the beginning on every new cycle.
   REVERSE means the animation
  will reverse directions on each iteration.
   */
  int32_t mRepeatMode_;
  /*!
   @brief Whether or not the animator should register for its own animation callback to receive
  animation pulse.
   */
  bool mSelfPulse_;
  /*!
   @brief Whether or not the animator has been requested to start without pulsing.This flag gets set
  in startWithoutPulsing(), and reset in start().
   */
  bool mSuppressSelfPulseRequested_;
  /*!
   @brief The time interpolator to be used.The elapsed fraction of the animation will be passed
  through this interpolator to calculate the interpolated fraction, which is then used to
  calculate the animated values.
   */
  id<ADTimeInterpolator> mInterpolator_;
  /*!
   @brief If set to non-negative value, this will override <code>sDurationScale</code>.
   */
  float mDurationScale_;
  /*!
   @brief Animation handler used to schedule updates for this animation.
   */
  ADAnimationHandler *mAnimationHandler_;
}

- (float)resolveDurationScale;

- (int64_t)getScaledDuration;

/*!
 @brief Calculates current iteration based on the overall fraction.The overall fraction will be
  in the range of [0, mRepeatCount + 1].
 Both current iteration and fraction in the current
  iteration can be derived from it.
 */
- (int32_t)getCurrentIterationWithFloat:(float)fraction;

/*!
 @brief Calculates the fraction of the current iteration, taking into account whether the animation
  should be played backwards.E.g.
 When the animation is played backwards in an iteration,
  the fraction for that iteration will go from 1f to 0f.
 */
- (float)getCurrentIterationFractionWithFloat:(float)fraction
                                  withBoolean:(bool)inReverse;

/*!
 @brief Clamps fraction into the correct range: [0, mRepeatCount + 1].If repeat count is infinite,
  no upper bound will be set for the fraction.
 @param fraction fraction to be clamped
 @return fraction clamped into the range of [0, mRepeatCount + 1]
 */
- (float)clampFractionWithFloat:(float)fraction;

/*!
 @brief Calculates the direction of animation playing (i.e.forward or backward), based on 1)
  whether the entire animation is being reversed, 2) repeat mode applied to the current
  iteration.
 */
- (bool)shouldPlayBackwardWithInt:(int32_t)iteration
                      withBoolean:(bool)inReverse;

/*!
 @brief Start the animation playing.This version of start() takes a boolean flag that indicates
  whether the animation should play in reverse.
 The flag is usually false, but may be set
  to true if called from the reverse() method. 
 <p>The animation started by calling this method will be run on the thread that called
  this method. This thread should have a Looper on it (a runtime exception will be thrown if
  this is not the case). Also, if the animation will animate
  properties of objects in the view hierarchy, then the calling thread should be the UI
  thread for that view hierarchy.</p>
 @param playBackwards Whether the ValueAnimator should start playing in reverse.
 */
- (void)startWithBoolean:(bool)playBackwards;

/*!
 @brief Called internally to end an animation by removing it from the animations list.Must be
  called on the UI thread.
 */
- (void)endAnimation;

/*!
 @brief Called internally to start an animation by adding it to the active animations list.Must be
  called on the UI thread.
 */
- (void)startAnimation;

/*!
 @brief Internal only: This tracks whether the animation has gotten on the animation loop.Note
  this is different than <code>isRunning()</code> in that the latter tracks the time after start()
  is called (or after start delay if any), which may be before the animation loop starts.
 */
- (bool)isPulsingInternal;

- (void)addOneShotCommitCallback;

- (void)removeAnimationCallback;

- (void)addAnimationCallbackWithLong:(int64_t)delay;

@end

J2OBJC_FIELD_SETTER(ADValueAnimator, mInterpolator_, id<ADTimeInterpolator>)
J2OBJC_FIELD_SETTER(ADValueAnimator, mAnimationHandler_, ADAnimationHandler *)

inline NSString *ADValueAnimator_get_TAG(void);
static NSString *ADValueAnimator_TAG = @"ValueAnimator";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADValueAnimator, TAG, NSString *)

inline bool ADValueAnimator_get_DEBUG(void);
#define ADValueAnimator_DEBUG false
J2OBJC_STATIC_FIELD_CONSTANT(ADValueAnimator, DEBUG, bool)

inline bool ADValueAnimator_get_TRACE_ANIMATION_FRACTION(void);
static bool ADValueAnimator_TRACE_ANIMATION_FRACTION;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(ADValueAnimator, TRACE_ANIMATION_FRACTION, bool)

/*!
 @brief System-wide animation scale.
 <p>To check whether animations are enabled system-wise use <code>areAnimatorsEnabled()</code>.
 */
inline float ADValueAnimator_get_sDurationScale(void);
inline float ADValueAnimator_set_sDurationScale(float value);
inline float *ADValueAnimator_getRef_sDurationScale(void);
static float ADValueAnimator_sDurationScale = 1.0f;
J2OBJC_STATIC_FIELD_PRIMITIVE(ADValueAnimator, sDurationScale, float)

inline JavaUtilArrayList *ADValueAnimator_get_sDurationScaleChangeListeners(void);
static JavaUtilArrayList *ADValueAnimator_sDurationScaleChangeListeners;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADValueAnimator, sDurationScaleChangeListeners, JavaUtilArrayList *)

inline id<ADTimeInterpolator> ADValueAnimator_get_sDefaultInterpolator(void);
static id<ADTimeInterpolator> ADValueAnimator_sDefaultInterpolator;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ADValueAnimator, sDefaultInterpolator, id<ADTimeInterpolator>)

__attribute__((unused)) static float ADValueAnimator_resolveDurationScale(ADValueAnimator *self);

__attribute__((unused)) static int64_t ADValueAnimator_getScaledDuration(ADValueAnimator *self);

__attribute__((unused)) static int32_t ADValueAnimator_getCurrentIterationWithFloat_(ADValueAnimator *self, float fraction);

__attribute__((unused)) static float ADValueAnimator_getCurrentIterationFractionWithFloat_withBoolean_(ADValueAnimator *self, float fraction, bool inReverse);

__attribute__((unused)) static float ADValueAnimator_clampFractionWithFloat_(ADValueAnimator *self, float fraction);

__attribute__((unused)) static bool ADValueAnimator_shouldPlayBackwardWithInt_withBoolean_(ADValueAnimator *self, int32_t iteration, bool inReverse);

__attribute__((unused)) static void ADValueAnimator_startWithBoolean_(ADValueAnimator *self, bool playBackwards);

__attribute__((unused)) static void ADValueAnimator_endAnimation(ADValueAnimator *self);

__attribute__((unused)) static void ADValueAnimator_startAnimation(ADValueAnimator *self);

__attribute__((unused)) static bool ADValueAnimator_isPulsingInternal(ADValueAnimator *self);

__attribute__((unused)) static bool ADValueAnimator_doAnimationFrameWithLong_(ADValueAnimator *self, int64_t frameTime);

__attribute__((unused)) static void ADValueAnimator_addOneShotCommitCallback(ADValueAnimator *self);

__attribute__((unused)) static void ADValueAnimator_removeAnimationCallback(ADValueAnimator *self);

__attribute__((unused)) static void ADValueAnimator_addAnimationCallbackWithLong_(ADValueAnimator *self, int64_t delay);

@interface ADValueAnimator_RepeatMode : NSObject

@end

__attribute__((unused)) static IOSObjectArray *ADValueAnimator_RepeatMode__Annotations$0(void);

@interface ADValueAnimator_AnimatorUpdateListener : NSObject

@end

@interface ADValueAnimator_DurationScaleChangeListener : NSObject

@end

J2OBJC_INITIALIZED_DEFN(ADValueAnimator)

@implementation ADValueAnimator

+ (void)setDurationScaleWithFloat:(float)durationScale {
  ADValueAnimator_setDurationScaleWithFloat_(durationScale);
}

+ (float)getDurationScale {
  return ADValueAnimator_getDurationScale();
}

+ (bool)registerDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener:(id<ADValueAnimator_DurationScaleChangeListener>)listener {
  return ADValueAnimator_registerDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener_(listener);
}

+ (bool)unregisterDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener:(id<ADValueAnimator_DurationScaleChangeListener>)listener {
  return ADValueAnimator_unregisterDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener_(listener);
}

+ (bool)areAnimatorsEnabled {
  return ADValueAnimator_areAnimatorsEnabled();
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  ADValueAnimator_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (ADValueAnimator *)ofIntWithIntArray:(IOSIntArray *)values {
  return ADValueAnimator_ofIntWithIntArray_(values);
}

+ (ADValueAnimator *)ofArgbWithIntArray:(IOSIntArray *)values {
  return ADValueAnimator_ofArgbWithIntArray_(values);
}

+ (ADValueAnimator *)ofFloatWithFloatArray:(IOSFloatArray *)values {
  return ADValueAnimator_ofFloatWithFloatArray_(values);
}

+ (ADValueAnimator *)ofPropertyValuesHolderWithADPropertyValuesHolderArray:(IOSObjectArray *)values {
  return ADValueAnimator_ofPropertyValuesHolderWithADPropertyValuesHolderArray_(values);
}

+ (ADValueAnimator *)ofObjectWithADTypeEvaluator:(id<ADTypeEvaluator>)evaluator
                               withNSObjectArray:(IOSObjectArray *)values {
  return ADValueAnimator_ofObjectWithADTypeEvaluator_withNSObjectArray_(evaluator, values);
}

- (void)setIntValuesWithIntArray:(IOSIntArray *)values {
  if (values == nil || values->size_ == 0) {
    return;
  }
  if (mValues_ == nil || mValues_->size_ == 0) {
    [self setValuesWithADPropertyValuesHolderArray:[IOSObjectArray arrayWithObjects:(id[]){ ADPropertyValuesHolder_ofIntWithNSString_withIntArray_(@"", values) } count:1 type:ADPropertyValuesHolder_class_()]];
  }
  else {
    ADPropertyValuesHolder *valuesHolder = IOSObjectArray_Get(mValues_, 0);
    [((ADPropertyValuesHolder *) nil_chk(valuesHolder)) setIntValuesWithIntArray:values];
  }
  mInitialized_ = false;
}

- (void)setFloatValuesWithFloatArray:(IOSFloatArray *)values {
  if (values == nil || values->size_ == 0) {
    return;
  }
  if (mValues_ == nil || mValues_->size_ == 0) {
    [self setValuesWithADPropertyValuesHolderArray:[IOSObjectArray arrayWithObjects:(id[]){ ADPropertyValuesHolder_ofFloatWithNSString_withFloatArray_(@"", values) } count:1 type:ADPropertyValuesHolder_class_()]];
  }
  else {
    ADPropertyValuesHolder *valuesHolder = IOSObjectArray_Get(mValues_, 0);
    [((ADPropertyValuesHolder *) nil_chk(valuesHolder)) setFloatValuesWithFloatArray:values];
  }
  mInitialized_ = false;
}

- (void)setObjectValuesWithNSObjectArray:(IOSObjectArray *)values {
  if (values == nil || values->size_ == 0) {
    return;
  }
  if (mValues_ == nil || mValues_->size_ == 0) {
    [self setValuesWithADPropertyValuesHolderArray:[IOSObjectArray arrayWithObjects:(id[]){ ADPropertyValuesHolder_ofObjectWithNSString_withADTypeEvaluator_withNSObjectArray_(@"", nil, values) } count:1 type:ADPropertyValuesHolder_class_()]];
  }
  else {
    ADPropertyValuesHolder *valuesHolder = IOSObjectArray_Get(mValues_, 0);
    [((ADPropertyValuesHolder *) nil_chk(valuesHolder)) setObjectValuesWithNSObjectArray:values];
  }
  mInitialized_ = false;
}

- (void)setValuesWithADPropertyValuesHolderArray:(IOSObjectArray *)values {
  int32_t numValues = ((IOSObjectArray *) nil_chk(values))->size_;
  JreStrongAssign(&mValues_, values);
  JreStrongAssignAndConsume(&mValuesMap_, new_JavaUtilHashMap_initWithInt_(numValues));
  for (int32_t i = 0; i < numValues; ++i) {
    ADPropertyValuesHolder *valuesHolder = IOSObjectArray_Get(values, i);
    [((JavaUtilHashMap *) nil_chk(mValuesMap_)) putWithId:[((ADPropertyValuesHolder *) nil_chk(valuesHolder)) getPropertyName] withId:valuesHolder];
  }
  mInitialized_ = false;
}

- (IOSObjectArray *)getValues {
  return mValues_;
}

- (void)initAnimation {
  if (!mInitialized_) {
    if (mValues_ != nil) {
      int32_t numValues = mValues_->size_;
      for (int32_t i = 0; i < numValues; ++i) {
        [((ADPropertyValuesHolder *) nil_chk(IOSObjectArray_Get(nil_chk(mValues_), i))) init__];
      }
    }
    mInitialized_ = true;
  }
}

- (ADValueAnimator *)setDurationWithLong:(int64_t)duration {
  if (duration < 0) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$J", @"Animators cannot have negative duration: ", duration));
  }
  mDuration_ = duration;
  return self;
}

- (void)overrideDurationScaleWithFloat:(float)durationScale {
  mDurationScale_ = durationScale;
}

- (float)resolveDurationScale {
  return ADValueAnimator_resolveDurationScale(self);
}

- (int64_t)getScaledDuration {
  return ADValueAnimator_getScaledDuration(self);
}

- (int64_t)getDuration {
  return mDuration_;
}

- (int64_t)getTotalDuration {
  if (mRepeatCount_ == ADValueAnimator_INFINITE) {
    return ADAnimator_DURATION_INFINITE;
  }
  else {
    return mStartDelay_ + (mDuration_ * (mRepeatCount_ + 1));
  }
}

- (void)setCurrentPlayTimeWithLong:(int64_t)playTime {
  float fraction = mDuration_ > 0 ? (float) playTime / mDuration_ : 1;
  [self setCurrentFractionWithFloat:fraction];
}

- (void)setCurrentFractionWithFloat:(float)fraction {
  [self initAnimation];
  fraction = ADValueAnimator_clampFractionWithFloat_(self, fraction);
  mStartTimeCommitted_ = true;
  if (ADValueAnimator_isPulsingInternal(self)) {
    int64_t seekTime = JreFpToLong((ADValueAnimator_getScaledDuration(self) * fraction));
    int64_t currentTime = ADAnimationUtils_currentAnimationTimeMillis();
    mStartTime_ = currentTime - seekTime;
  }
  else {
    mSeekFraction_ = fraction;
  }
  mOverallFraction_ = fraction;
  float currentIterationFraction = ADValueAnimator_getCurrentIterationFractionWithFloat_withBoolean_(self, fraction, mReversing_);
  [self animateValueWithFloat:currentIterationFraction];
}

- (int32_t)getCurrentIterationWithFloat:(float)fraction {
  return ADValueAnimator_getCurrentIterationWithFloat_(self, fraction);
}

- (float)getCurrentIterationFractionWithFloat:(float)fraction
                                  withBoolean:(bool)inReverse {
  return ADValueAnimator_getCurrentIterationFractionWithFloat_withBoolean_(self, fraction, inReverse);
}

- (float)clampFractionWithFloat:(float)fraction {
  return ADValueAnimator_clampFractionWithFloat_(self, fraction);
}

- (bool)shouldPlayBackwardWithInt:(int32_t)iteration
                      withBoolean:(bool)inReverse {
  return ADValueAnimator_shouldPlayBackwardWithInt_withBoolean_(self, iteration, inReverse);
}

- (int64_t)getCurrentPlayTime {
  if (!mInitialized_ || (!mStarted_ && mSeekFraction_ < 0)) {
    return 0;
  }
  if (mSeekFraction_ >= 0) {
    return JreFpToLong((mDuration_ * mSeekFraction_));
  }
  float durationScale = ADValueAnimator_resolveDurationScale(self);
  if (durationScale == 0.0f) {
    durationScale = 1.0f;
  }
  return JreFpToLong(((ADAnimationUtils_currentAnimationTimeMillis() - mStartTime_) / durationScale));
}

- (int64_t)getStartDelay {
  return mStartDelay_;
}

- (void)setStartDelayWithLong:(int64_t)startDelay {
  if (startDelay < 0) {
    ADLog_wWithNSString_withNSString_(ADValueAnimator_TAG, @"Start delay should always be non-negative");
    startDelay = 0;
  }
  mStartDelay_ = startDelay;
}

+ (int64_t)getFrameDelay {
  return ADValueAnimator_getFrameDelay();
}

+ (void)setFrameDelayWithLong:(int64_t)frameDelay {
  ADValueAnimator_setFrameDelayWithLong_(frameDelay);
}

- (id)getAnimatedValue {
  if (mValues_ != nil && mValues_->size_ > 0) {
    return [((ADPropertyValuesHolder *) nil_chk(IOSObjectArray_Get(mValues_, 0))) getAnimatedValue];
  }
  return nil;
}

- (id)getAnimatedValueWithNSString:(NSString *)propertyName {
  ADPropertyValuesHolder *valuesHolder = JreRetainedLocalValue([((JavaUtilHashMap *) nil_chk(mValuesMap_)) getWithId:propertyName]);
  if (valuesHolder != nil) {
    return [valuesHolder getAnimatedValue];
  }
  else {
    return nil;
  }
}

- (void)setRepeatCountWithInt:(int32_t)value {
  mRepeatCount_ = value;
}

- (int32_t)getRepeatCount {
  return mRepeatCount_;
}

- (void)setRepeatModeWithInt:(int32_t)value {
  mRepeatMode_ = value;
}

- (int32_t)getRepeatMode {
  return mRepeatMode_;
}

- (void)addUpdateListenerWithADValueAnimator_AnimatorUpdateListener:(id<ADValueAnimator_AnimatorUpdateListener>)listener {
  if (mUpdateListeners_ == nil) {
    JreStrongAssignAndConsume(&mUpdateListeners_, new_JavaUtilArrayList_init());
  }
  [mUpdateListeners_ addWithId:listener];
}

- (void)removeAllUpdateListeners {
  if (mUpdateListeners_ == nil) {
    return;
  }
  [mUpdateListeners_ clear];
  JreStrongAssign(&mUpdateListeners_, nil);
}

- (void)removeUpdateListenerWithADValueAnimator_AnimatorUpdateListener:(id<ADValueAnimator_AnimatorUpdateListener>)listener {
  if (mUpdateListeners_ == nil) {
    return;
  }
  [mUpdateListeners_ removeWithId:listener];
  if ([((JavaUtilArrayList *) nil_chk(mUpdateListeners_)) size] == 0) {
    JreStrongAssign(&mUpdateListeners_, nil);
  }
}

- (void)setInterpolatorWithADTimeInterpolator:(id<ADTimeInterpolator>)value {
  if (value != nil) {
    JreStrongAssign(&mInterpolator_, value);
  }
  else {
    JreStrongAssignAndConsume(&mInterpolator_, new_ADLinearInterpolator_init());
  }
}

- (id<ADTimeInterpolator>)getInterpolator {
  return mInterpolator_;
}

- (void)setEvaluatorWithADTypeEvaluator:(id<ADTypeEvaluator>)value {
  if (value != nil && mValues_ != nil && mValues_->size_ > 0) {
    [((ADPropertyValuesHolder *) nil_chk(IOSObjectArray_Get(mValues_, 0))) setEvaluatorWithADTypeEvaluator:value];
  }
}

- (void)startWithBoolean:(bool)playBackwards {
  ADValueAnimator_startWithBoolean_(self, playBackwards);
}

- (void)startWithoutPulsingWithBoolean:(bool)inReverse {
  mSuppressSelfPulseRequested_ = true;
  if (inReverse) {
    [self reverse];
  }
  else {
    [self start];
  }
  mSuppressSelfPulseRequested_ = false;
}

- (void)start {
  ADValueAnimator_startWithBoolean_(self, false);
}

- (void)cancel {
  if (ADLooper_myLooper() == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Animators may only be run on Looper threads");
  }
  if (mAnimationEndRequested_) {
    return;
  }
  if ((mStarted_ || mRunning_ || mStartListenersCalled_) && mListeners_ != nil) {
    if (!mRunning_) {
      [self notifyStartListenersWithBoolean:mReversing_];
    }
    [self notifyListenersWithADAnimator_AnimatorCaller:JreLoadStatic(ADAnimator_AnimatorCaller, ON_CANCEL) withBoolean:false];
  }
  ADValueAnimator_endAnimation(self);
}

- (void)end {
  if (ADLooper_myLooper() == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Animators may only be run on Looper threads");
  }
  if (!mRunning_) {
    ADValueAnimator_startAnimation(self);
    mStarted_ = true;
  }
  else if (!mInitialized_) {
    [self initAnimation];
  }
  [self animateValueWithFloat:ADValueAnimator_shouldPlayBackwardWithInt_withBoolean_(self, mRepeatCount_, mReversing_) ? 0.0f : 1.0f];
  ADValueAnimator_endAnimation(self);
}

- (void)resume {
  if (ADLooper_myLooper() == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Animators may only be resumed from the same thread that the animator was started on");
  }
  if (mPaused_ && !mResumed_) {
    mResumed_ = true;
    if (mPauseTime_ > 0) {
      ADValueAnimator_addAnimationCallbackWithLong_(self, 0);
    }
  }
  [super resume];
}

- (void)pause {
  bool previouslyPaused = mPaused_;
  [super pause];
  if (!previouslyPaused && mPaused_) {
    mPauseTime_ = -1;
    mResumed_ = false;
  }
}

- (bool)isRunning {
  return mRunning_;
}

- (bool)isStarted {
  return mStarted_;
}

- (void)reverse {
  if (ADValueAnimator_isPulsingInternal(self)) {
    int64_t currentTime = ADAnimationUtils_currentAnimationTimeMillis();
    int64_t currentPlayTime = currentTime - mStartTime_;
    int64_t timeLeft = ADValueAnimator_getScaledDuration(self) - currentPlayTime;
    mStartTime_ = currentTime - timeLeft;
    mStartTimeCommitted_ = true;
    mReversing_ = !mReversing_;
  }
  else if (mStarted_) {
    mReversing_ = !mReversing_;
    [self end];
  }
  else {
    ADValueAnimator_startWithBoolean_(self, true);
  }
}

- (bool)canReverse {
  return true;
}

- (void)endAnimation {
  ADValueAnimator_endAnimation(self);
}

- (void)startAnimation {
  ADValueAnimator_startAnimation(self);
}

- (bool)isPulsingInternal {
  return ADValueAnimator_isPulsingInternal(self);
}

- (NSString *)getNameForTrace {
  return @"animator";
}

- (void)commitAnimationFrameWithLong:(int64_t)frameTime {
  if (!mStartTimeCommitted_) {
    mStartTimeCommitted_ = true;
    int64_t adjustment = frameTime - mLastFrameTime_;
    if (adjustment > 0) {
      mStartTime_ += adjustment;
    }
  }
}

- (bool)animateBasedOnTimeWithLong:(int64_t)currentTime {
  bool done = false;
  if (mRunning_) {
    int64_t scaledDuration = ADValueAnimator_getScaledDuration(self);
    float fraction = scaledDuration > 0 ? (float) (currentTime - mStartTime_) / scaledDuration : 1.0f;
    float lastFraction = mOverallFraction_;
    bool newIteration = JreFpToInt(fraction) > JreFpToInt(lastFraction);
    bool lastIterationFinished = (fraction >= mRepeatCount_ + 1) && (mRepeatCount_ != ADValueAnimator_INFINITE);
    if (scaledDuration == 0) {
      done = true;
    }
    else if (newIteration && !lastIterationFinished) {
      [self notifyListenersWithADAnimator_AnimatorCaller:JreLoadStatic(ADAnimator_AnimatorCaller, ON_REPEAT) withBoolean:false];
    }
    else if (lastIterationFinished) {
      done = true;
    }
    mOverallFraction_ = ADValueAnimator_clampFractionWithFloat_(self, fraction);
    float currentIterationFraction = ADValueAnimator_getCurrentIterationFractionWithFloat_withBoolean_(self, mOverallFraction_, mReversing_);
    [self animateValueWithFloat:currentIterationFraction];
  }
  return done;
}

- (void)animateValuesInRangeWithLong:(int64_t)currentPlayTime
                            withLong:(int64_t)lastPlayTime {
  if (currentPlayTime < 0 || lastPlayTime < -1) {
    @throw create_JavaLangUnsupportedOperationException_initWithNSString_(@"Error: Play time should never be negative.");
  }
  [self initAnimation];
  int64_t duration = [self getTotalDuration];
  if (lastPlayTime < 0 || (lastPlayTime == 0 && currentPlayTime > 0)) {
    [self notifyStartListenersWithBoolean:false];
  }
  else if (lastPlayTime > duration || (lastPlayTime == duration && currentPlayTime < duration)) {
    [self notifyStartListenersWithBoolean:true];
  }
  if (duration >= 0) {
    lastPlayTime = JavaLangMath_minWithLong_withLong_(duration, lastPlayTime);
  }
  lastPlayTime -= mStartDelay_;
  currentPlayTime -= mStartDelay_;
  if (mRepeatCount_ > 0) {
    int32_t iteration = JavaLangMath_maxWithInt_withInt_(0, (int32_t) (JreLongDiv(currentPlayTime, mDuration_)));
    int32_t lastIteration = JavaLangMath_maxWithInt_withInt_(0, (int32_t) (JreLongDiv(lastPlayTime, mDuration_)));
    iteration = JavaLangMath_minWithInt_withInt_(iteration, mRepeatCount_);
    lastIteration = JavaLangMath_minWithInt_withInt_(lastIteration, mRepeatCount_);
    if (iteration != lastIteration) {
      [self notifyListenersWithADAnimator_AnimatorCaller:JreLoadStatic(ADAnimator_AnimatorCaller, ON_REPEAT) withBoolean:false];
    }
  }
  if (mRepeatCount_ != ADValueAnimator_INFINITE && currentPlayTime > (mRepeatCount_ + 1) * mDuration_) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Can't animate a value outside of the duration");
  }
  else {
    float fraction = JavaLangMath_maxWithLong_withLong_(0, currentPlayTime) / (float) mDuration_;
    fraction = ADValueAnimator_getCurrentIterationFractionWithFloat_withBoolean_(self, fraction, false);
    [self animateValueWithFloat:fraction];
  }
}

- (void)animateSkipToEndsWithLong:(int64_t)currentPlayTime
                         withLong:(int64_t)lastPlayTime {
  bool inReverse = currentPlayTime < lastPlayTime;
  bool doSkip;
  if (currentPlayTime <= 0 && lastPlayTime > 0) {
    doSkip = true;
  }
  else {
    int64_t duration = [self getTotalDuration];
    doSkip = (duration >= 0 && currentPlayTime >= duration && lastPlayTime < duration);
  }
  if (doSkip) {
    [self notifyStartListenersWithBoolean:inReverse];
    [self skipToEndValueWithBoolean:inReverse];
    [self notifyEndListenersWithBoolean:inReverse];
  }
}

- (void)skipToEndValueWithBoolean:(bool)inReverse {
  [self initAnimation];
  float endFraction = inReverse ? 0.0f : 1.0f;
  if (JreIntMod(mRepeatCount_, 2) == 1 && mRepeatMode_ == ADValueAnimator_REVERSE) {
    endFraction = 0.0f;
  }
  [self animateValueWithFloat:endFraction];
}

- (bool)isInitialized {
  return mInitialized_;
}

- (bool)doAnimationFrameWithLong:(int64_t)frameTime {
  return ADValueAnimator_doAnimationFrameWithLong_(self, frameTime);
}

- (bool)pulseAnimationFrameWithLong:(int64_t)frameTime {
  if (mSelfPulse_) {
    return false;
  }
  return ADValueAnimator_doAnimationFrameWithLong_(self, frameTime);
}

- (void)addOneShotCommitCallback {
  ADValueAnimator_addOneShotCommitCallback(self);
}

- (void)removeAnimationCallback {
  ADValueAnimator_removeAnimationCallback(self);
}

- (void)addAnimationCallbackWithLong:(int64_t)delay {
  ADValueAnimator_addAnimationCallbackWithLong_(self, delay);
}

- (float)getAnimatedFraction {
  return mCurrentFraction_;
}

- (void)animateValueWithFloat:(float)fraction {
  if (ADValueAnimator_TRACE_ANIMATION_FRACTION) {
    ADTrace_traceCounterWithInt_withNSString_withInt_(ADTrace_TRACE_TAG_VIEW, JreStrcat("$I", [self getNameForTrace], ((int32_t) [self hash])), JreFpToInt((fraction * 1000)));
  }
  if (mValues_ == nil) {
    return;
  }
  fraction = [((id<ADTimeInterpolator>) nil_chk(mInterpolator_)) getInterpolationWithFloat:fraction];
  mCurrentFraction_ = fraction;
  int32_t numValues = ((IOSObjectArray *) nil_chk(mValues_))->size_;
  for (int32_t i = 0; i < numValues; ++i) {
    [((ADPropertyValuesHolder *) nil_chk(IOSObjectArray_Get(nil_chk(mValues_), i))) calculateValueWithFloat:fraction];
  }
  if (mSeekFraction_ >= 0 || mStartListenersCalled_) {
    [self callOnListWithJavaUtilArrayList:mUpdateListeners_ withADAnimator_AnimatorCaller:JreLoadStatic(ADAnimator_AnimatorCaller, ON_UPDATE) withId:self withBoolean:false];
  }
}

- (ADValueAnimator *)java_clone {
  ADValueAnimator *anim = (ADValueAnimator *) cast_chk([super java_clone], [ADValueAnimator class]);
  if (mUpdateListeners_ != nil) {
    JreStrongAssignAndConsume(&((ADValueAnimator *) nil_chk(anim))->mUpdateListeners_, new_JavaUtilArrayList_initWithJavaUtilCollection_(mUpdateListeners_));
  }
  ((ADValueAnimator *) nil_chk(anim))->mSeekFraction_ = -1;
  anim->mReversing_ = false;
  anim->mInitialized_ = false;
  anim->mStarted_ = false;
  anim->mRunning_ = false;
  anim->mPaused_ = false;
  anim->mResumed_ = false;
  anim->mStartTime_ = -1;
  anim->mStartTimeCommitted_ = false;
  anim->mAnimationEndRequested_ = false;
  anim->mPauseTime_ = -1;
  anim->mLastFrameTime_ = -1;
  anim->mFirstFrameTime_ = -1;
  anim->mOverallFraction_ = 0;
  anim->mCurrentFraction_ = 0;
  anim->mSelfPulse_ = true;
  anim->mSuppressSelfPulseRequested_ = false;
  IOSObjectArray *oldValues = mValues_;
  if (oldValues != nil) {
    int32_t numValues = oldValues->size_;
    JreStrongAssignAndConsume(&anim->mValues_, [IOSObjectArray newArrayWithLength:numValues type:ADPropertyValuesHolder_class_()]);
    JreStrongAssignAndConsume(&anim->mValuesMap_, new_JavaUtilHashMap_initWithInt_(numValues));
    for (int32_t i = 0; i < numValues; ++i) {
      ADPropertyValuesHolder *newValuesHolder = JreRetainedLocalValue([((ADPropertyValuesHolder *) nil_chk(IOSObjectArray_Get(oldValues, i))) java_clone]);
      IOSObjectArray_Set(nil_chk(anim->mValues_), i, newValuesHolder);
      [((JavaUtilHashMap *) nil_chk(anim->mValuesMap_)) putWithId:[((ADPropertyValuesHolder *) nil_chk(newValuesHolder)) getPropertyName] withId:newValuesHolder];
    }
  }
  return anim;
}

+ (int32_t)getCurrentAnimationsCount {
  return ADValueAnimator_getCurrentAnimationsCount();
}

- (NSString *)description {
  NSString *returnVal = JreStrcat("$$", @"ValueAnimator@", JavaLangInteger_toHexStringWithInt_(((int32_t) [self hash])));
  if (mValues_ != nil) {
    for (int32_t i = 0; i < ((IOSObjectArray *) nil_chk(mValues_))->size_; ++i) {
      JreStrAppend(&returnVal, "$$", @"\n    ", [((ADPropertyValuesHolder *) nil_chk(IOSObjectArray_Get(mValues_, i))) description]);
    }
  }
  return returnVal;
}

- (void)setAllowRunningAsynchronouslyWithBoolean:(bool)mayRunAsync {
}

- (ADAnimationHandler *)getAnimationHandler {
  return mAnimationHandler_ != nil ? mAnimationHandler_ : ADAnimationHandler_getInstance();
}

- (void)setAnimationHandlerWithADAnimationHandler:(ADAnimationHandler *)animationHandler {
  JreStrongAssign(&mAnimationHandler_, animationHandler);
}

- (void)dealloc {
  RELEASE_(mInterpolator_);
  RELEASE_(mUpdateListeners_);
  RELEASE_(mValues_);
  RELEASE_(mValuesMap_);
  RELEASE_(mAnimationHandler_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "F", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x9, 2, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x9, 4, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADValueAnimator;", 0x89, 5, 6, -1, -1, -1, -1 },
    { NULL, "LADValueAnimator;", 0x89, 7, 6, -1, -1, -1, -1 },
    { NULL, "LADValueAnimator;", 0x89, 8, 9, -1, -1, -1, -1 },
    { NULL, "LADValueAnimator;", 0x89, 10, 11, -1, -1, -1, -1 },
    { NULL, "LADValueAnimator;", 0x89, 12, 13, -1, -1, -1, -1 },
    { NULL, "V", 0x81, 14, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x81, 15, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x81, 16, 17, -1, -1, -1, -1 },
    { NULL, "V", 0x81, 18, 11, -1, -1, -1, -1 },
    { NULL, "[LADPropertyValuesHolder;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LADValueAnimator;", 0x1, 19, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 21, 1, -1, -1, -1, -1 },
    { NULL, "F", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 22, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 23, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 24, 1, -1, -1, -1, -1 },
    { NULL, "F", 0x2, 25, 26, -1, -1, -1, -1 },
    { NULL, "F", 0x2, 27, 1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 28, 29, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 30, 20, -1, -1, -1, -1 },
    { NULL, "J", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 31, 20, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 32, 33, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 34, 35, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 36, 35, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 37, 38, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 39, 38, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 40, 41, -1, -1, -1, -1 },
    { NULL, "LADTimeInterpolator;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 42, 43, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 44, 45, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 46, 45, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 47, 20, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 48, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 49, 50, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 51, 50, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 52, 45, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x11, 53, 20, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 54, 20, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 55, 20, -1, -1, -1, -1 },
    { NULL, "F", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 56, 1, -1, -1, -1, -1 },
    { NULL, "LADValueAnimator;", 0x1, 57, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 58, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 59, 45, -1, -1, -1, -1 },
    { NULL, "LADAnimationHandler;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 60, 61, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(setDurationScaleWithFloat:);
  methods[1].selector = @selector(getDurationScale);
  methods[2].selector = @selector(registerDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener:);
  methods[3].selector = @selector(unregisterDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener:);
  methods[4].selector = @selector(areAnimatorsEnabled);
  methods[5].selector = @selector(init);
  methods[6].selector = @selector(ofIntWithIntArray:);
  methods[7].selector = @selector(ofArgbWithIntArray:);
  methods[8].selector = @selector(ofFloatWithFloatArray:);
  methods[9].selector = @selector(ofPropertyValuesHolderWithADPropertyValuesHolderArray:);
  methods[10].selector = @selector(ofObjectWithADTypeEvaluator:withNSObjectArray:);
  methods[11].selector = @selector(setIntValuesWithIntArray:);
  methods[12].selector = @selector(setFloatValuesWithFloatArray:);
  methods[13].selector = @selector(setObjectValuesWithNSObjectArray:);
  methods[14].selector = @selector(setValuesWithADPropertyValuesHolderArray:);
  methods[15].selector = @selector(getValues);
  methods[16].selector = @selector(initAnimation);
  methods[17].selector = @selector(setDurationWithLong:);
  methods[18].selector = @selector(overrideDurationScaleWithFloat:);
  methods[19].selector = @selector(resolveDurationScale);
  methods[20].selector = @selector(getScaledDuration);
  methods[21].selector = @selector(getDuration);
  methods[22].selector = @selector(getTotalDuration);
  methods[23].selector = @selector(setCurrentPlayTimeWithLong:);
  methods[24].selector = @selector(setCurrentFractionWithFloat:);
  methods[25].selector = @selector(getCurrentIterationWithFloat:);
  methods[26].selector = @selector(getCurrentIterationFractionWithFloat:withBoolean:);
  methods[27].selector = @selector(clampFractionWithFloat:);
  methods[28].selector = @selector(shouldPlayBackwardWithInt:withBoolean:);
  methods[29].selector = @selector(getCurrentPlayTime);
  methods[30].selector = @selector(getStartDelay);
  methods[31].selector = @selector(setStartDelayWithLong:);
  methods[32].selector = @selector(getFrameDelay);
  methods[33].selector = @selector(setFrameDelayWithLong:);
  methods[34].selector = @selector(getAnimatedValue);
  methods[35].selector = @selector(getAnimatedValueWithNSString:);
  methods[36].selector = @selector(setRepeatCountWithInt:);
  methods[37].selector = @selector(getRepeatCount);
  methods[38].selector = @selector(setRepeatModeWithInt:);
  methods[39].selector = @selector(getRepeatMode);
  methods[40].selector = @selector(addUpdateListenerWithADValueAnimator_AnimatorUpdateListener:);
  methods[41].selector = @selector(removeAllUpdateListeners);
  methods[42].selector = @selector(removeUpdateListenerWithADValueAnimator_AnimatorUpdateListener:);
  methods[43].selector = @selector(setInterpolatorWithADTimeInterpolator:);
  methods[44].selector = @selector(getInterpolator);
  methods[45].selector = @selector(setEvaluatorWithADTypeEvaluator:);
  methods[46].selector = @selector(startWithBoolean:);
  methods[47].selector = @selector(startWithoutPulsingWithBoolean:);
  methods[48].selector = @selector(start);
  methods[49].selector = @selector(cancel);
  methods[50].selector = @selector(end);
  methods[51].selector = @selector(resume);
  methods[52].selector = @selector(pause);
  methods[53].selector = @selector(isRunning);
  methods[54].selector = @selector(isStarted);
  methods[55].selector = @selector(reverse);
  methods[56].selector = @selector(canReverse);
  methods[57].selector = @selector(endAnimation);
  methods[58].selector = @selector(startAnimation);
  methods[59].selector = @selector(isPulsingInternal);
  methods[60].selector = @selector(getNameForTrace);
  methods[61].selector = @selector(commitAnimationFrameWithLong:);
  methods[62].selector = @selector(animateBasedOnTimeWithLong:);
  methods[63].selector = @selector(animateValuesInRangeWithLong:withLong:);
  methods[64].selector = @selector(animateSkipToEndsWithLong:withLong:);
  methods[65].selector = @selector(skipToEndValueWithBoolean:);
  methods[66].selector = @selector(isInitialized);
  methods[67].selector = @selector(doAnimationFrameWithLong:);
  methods[68].selector = @selector(pulseAnimationFrameWithLong:);
  methods[69].selector = @selector(addOneShotCommitCallback);
  methods[70].selector = @selector(removeAnimationCallback);
  methods[71].selector = @selector(addAnimationCallbackWithLong:);
  methods[72].selector = @selector(getAnimatedFraction);
  methods[73].selector = @selector(animateValueWithFloat:);
  methods[74].selector = @selector(java_clone);
  methods[75].selector = @selector(getCurrentAnimationsCount);
  methods[76].selector = @selector(description);
  methods[77].selector = @selector(setAllowRunningAsynchronouslyWithBoolean:);
  methods[78].selector = @selector(getAnimationHandler);
  methods[79].selector = @selector(setAnimationHandlerWithADAnimationHandler:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 62, -1, -1 },
    { "DEBUG", "Z", .constantValue.asBOOL = ADValueAnimator_DEBUG, 0x1a, -1, -1, -1, -1 },
    { "TRACE_ANIMATION_FRACTION", "Z", .constantValue.asLong = 0, 0x1a, -1, 63, -1, -1 },
    { "sDurationScale", "F", .constantValue.asLong = 0, 0xa, -1, 64, -1, -1 },
    { "sDurationScaleChangeListeners", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x1a, -1, 65, 66, -1 },
    { "mStartTime_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mStartTimeCommitted_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mSeekFraction_", "F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mPauseTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mResumed_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "sDefaultInterpolator", "LADTimeInterpolator;", .constantValue.asLong = 0, 0x1a, -1, 67, -1, -1 },
    { "mReversing_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mOverallFraction_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mCurrentFraction_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mLastFrameTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mFirstFrameTime_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mRunning_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStarted_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mInitialized_", "Z", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mAnimationEndRequested_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mDuration_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mStartDelay_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mRepeatCount_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mRepeatMode_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mSelfPulse_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mSuppressSelfPulseRequested_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mInterpolator_", "LADTimeInterpolator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mUpdateListeners_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x0, -1, -1, 68, -1 },
    { "mValues_", "[LADPropertyValuesHolder;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "mValuesMap_", "LJavaUtilHashMap;", .constantValue.asLong = 0, 0x0, -1, -1, 69, -1 },
    { "mDurationScale_", "F", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mAnimationHandler_", "LADAnimationHandler;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "RESTART", "I", .constantValue.asInt = ADValueAnimator_RESTART, 0x19, -1, -1, -1, -1 },
    { "REVERSE", "I", .constantValue.asInt = ADValueAnimator_REVERSE, 0x19, -1, -1, -1, -1 },
    { "INFINITE", "I", .constantValue.asInt = ADValueAnimator_INFINITE, 0x19, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "setDurationScale", "F", "registerDurationScaleChangeListener", "LADValueAnimator_DurationScaleChangeListener;", "unregisterDurationScaleChangeListener", "ofInt", "[I", "ofArgb", "ofFloat", "[F", "ofPropertyValuesHolder", "[LADPropertyValuesHolder;", "ofObject", "LADTypeEvaluator;[LNSObject;", "setIntValues", "setFloatValues", "setObjectValues", "[LNSObject;", "setValues", "setDuration", "J", "overrideDurationScale", "setCurrentPlayTime", "setCurrentFraction", "getCurrentIteration", "getCurrentIterationFraction", "FZ", "clampFraction", "shouldPlayBackward", "IZ", "setStartDelay", "setFrameDelay", "getAnimatedValue", "LNSString;", "setRepeatCount", "I", "setRepeatMode", "addUpdateListener", "LADValueAnimator_AnimatorUpdateListener;", "removeUpdateListener", "setInterpolator", "LADTimeInterpolator;", "setEvaluator", "LADTypeEvaluator;", "start", "Z", "startWithoutPulsing", "commitAnimationFrame", "animateBasedOnTime", "animateValuesInRange", "JJ", "animateSkipToEnds", "skipToEndValue", "doAnimationFrame", "pulseAnimationFrame", "addAnimationCallback", "animateValue", "clone", "toString", "setAllowRunningAsynchronously", "setAnimationHandler", "LADAnimationHandler;", &ADValueAnimator_TAG, &ADValueAnimator_TRACE_ANIMATION_FRACTION, &ADValueAnimator_sDurationScale, &ADValueAnimator_sDurationScaleChangeListeners, "Ljava/util/ArrayList<Ljava/lang/ref/WeakReference<Lr/android/animation/ValueAnimator$DurationScaleChangeListener;>;>;", &ADValueAnimator_sDefaultInterpolator, "Ljava/util/ArrayList<Lr/android/animation/ValueAnimator$AnimatorUpdateListener;>;", "Ljava/util/HashMap<Ljava/lang/String;Lr/android/animation/PropertyValuesHolder;>;", "LADValueAnimator_RepeatMode;LADValueAnimator_AnimatorUpdateListener;LADValueAnimator_DurationScaleChangeListener;" };
  static const J2ObjcClassInfo _ADValueAnimator = { "ValueAnimator", "r.android.animation", ptrTable, methods, fields, 7, 0x1, 80, 35, -1, 70, -1, -1, -1 };
  return &_ADValueAnimator;
}

+ (void)initialize {
  if (self == [ADValueAnimator class]) {
    ADValueAnimator_TRACE_ANIMATION_FRACTION = ADSystemProperties_getBooleanWithNSString_withBoolean_(@"persist.debug.animator.trace_fraction", false);
    JreStrongAssignAndConsume(&ADValueAnimator_sDurationScaleChangeListeners, new_JavaUtilArrayList_init());
    JreStrongAssignAndConsume(&ADValueAnimator_sDefaultInterpolator, new_ADAccelerateDecelerateInterpolator_init());
    J2OBJC_SET_INITIALIZED(ADValueAnimator)
  }
}

@end

void ADValueAnimator_setDurationScaleWithFloat_(float durationScale) {
  ADValueAnimator_initialize();
  ADValueAnimator_sDurationScale = durationScale;
  id<JavaUtilList> listenerCopy;
  @synchronized(ADValueAnimator_sDurationScaleChangeListeners) {
    listenerCopy = create_JavaUtilArrayList_initWithJavaUtilCollection_(ADValueAnimator_sDurationScaleChangeListeners);
  }
  int32_t listenersSize = [listenerCopy size];
  for (int32_t i = 0; i < listenersSize; i++) {
    id<ADValueAnimator_DurationScaleChangeListener> listener = [((JavaLangRefWeakReference *) nil_chk([listenerCopy getWithInt:i])) get];
    if (listener != nil) {
      [listener onChangedWithFloat:durationScale];
    }
  }
}

float ADValueAnimator_getDurationScale() {
  ADValueAnimator_initialize();
  return ADValueAnimator_sDurationScale;
}

bool ADValueAnimator_registerDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener_(id<ADValueAnimator_DurationScaleChangeListener> listener) {
  ADValueAnimator_initialize();
  int32_t posToReplace = -1;
  @synchronized(ADValueAnimator_sDurationScaleChangeListeners) {
    for (int32_t i = 0; i < [((JavaUtilArrayList *) nil_chk(ADValueAnimator_sDurationScaleChangeListeners)) size]; i++) {
      JavaLangRefWeakReference *ref = [ADValueAnimator_sDurationScaleChangeListeners getWithInt:i];
      if ([((JavaLangRefWeakReference *) nil_chk(ref)) get] == nil) {
        if (posToReplace == -1) {
          posToReplace = i;
        }
      }
      else if (JreObjectEqualsEquals([ref get], listener)) {
        return false;
      }
    }
    if (posToReplace != -1) {
      [ADValueAnimator_sDurationScaleChangeListeners setWithInt:posToReplace withId:create_JavaLangRefWeakReference_initWithId_(listener)];
      return true;
    }
    else {
      return [ADValueAnimator_sDurationScaleChangeListeners addWithId:create_JavaLangRefWeakReference_initWithId_(listener)];
    }
  }
}

bool ADValueAnimator_unregisterDurationScaleChangeListenerWithADValueAnimator_DurationScaleChangeListener_(id<ADValueAnimator_DurationScaleChangeListener> listener) {
  ADValueAnimator_initialize();
  @synchronized(ADValueAnimator_sDurationScaleChangeListeners) {
    JavaLangRefWeakReference *listenerRefToRemove = nil;
    for (JavaLangRefWeakReference * __strong listenerRef in nil_chk(ADValueAnimator_sDurationScaleChangeListeners)) {
      if (JreObjectEqualsEquals([((JavaLangRefWeakReference *) nil_chk(listenerRef)) get], listener)) {
        listenerRefToRemove = listenerRef;
        break;
      }
    }
    return [ADValueAnimator_sDurationScaleChangeListeners removeWithId:listenerRefToRemove];
  }
}

bool ADValueAnimator_areAnimatorsEnabled() {
  ADValueAnimator_initialize();
  return !(ADValueAnimator_sDurationScale == 0);
}

void ADValueAnimator_init(ADValueAnimator *self) {
  ADAnimator_init(self);
  self->mStartTime_ = -1;
  self->mSeekFraction_ = -1;
  self->mResumed_ = false;
  self->mOverallFraction_ = 0.0f;
  self->mCurrentFraction_ = 0.0f;
  self->mLastFrameTime_ = -1;
  self->mFirstFrameTime_ = -1;
  self->mRunning_ = false;
  self->mStarted_ = false;
  self->mInitialized_ = false;
  self->mAnimationEndRequested_ = false;
  self->mDuration_ = 300;
  self->mStartDelay_ = 0;
  self->mRepeatCount_ = 0;
  self->mRepeatMode_ = ADValueAnimator_RESTART;
  self->mSelfPulse_ = true;
  self->mSuppressSelfPulseRequested_ = false;
  JreStrongAssign(&self->mInterpolator_, ADValueAnimator_sDefaultInterpolator);
  JreStrongAssign(&self->mUpdateListeners_, nil);
  self->mDurationScale_ = -1.0f;
}

ADValueAnimator *new_ADValueAnimator_init() {
  J2OBJC_NEW_IMPL(ADValueAnimator, init)
}

ADValueAnimator *create_ADValueAnimator_init() {
  J2OBJC_CREATE_IMPL(ADValueAnimator, init)
}

ADValueAnimator *ADValueAnimator_ofIntWithIntArray_(IOSIntArray *values) {
  ADValueAnimator_initialize();
  ADValueAnimator *anim = create_ADValueAnimator_init();
  [anim setIntValuesWithIntArray:values];
  return anim;
}

ADValueAnimator *ADValueAnimator_ofArgbWithIntArray_(IOSIntArray *values) {
  ADValueAnimator_initialize();
  ADValueAnimator *anim = create_ADValueAnimator_init();
  [anim setIntValuesWithIntArray:values];
  [anim setEvaluatorWithADTypeEvaluator:ADArgbEvaluator_getInstance()];
  return anim;
}

ADValueAnimator *ADValueAnimator_ofFloatWithFloatArray_(IOSFloatArray *values) {
  ADValueAnimator_initialize();
  ADValueAnimator *anim = create_ADValueAnimator_init();
  [anim setFloatValuesWithFloatArray:values];
  return anim;
}

ADValueAnimator *ADValueAnimator_ofPropertyValuesHolderWithADPropertyValuesHolderArray_(IOSObjectArray *values) {
  ADValueAnimator_initialize();
  ADValueAnimator *anim = create_ADValueAnimator_init();
  [anim setValuesWithADPropertyValuesHolderArray:values];
  return anim;
}

ADValueAnimator *ADValueAnimator_ofObjectWithADTypeEvaluator_withNSObjectArray_(id<ADTypeEvaluator> evaluator, IOSObjectArray *values) {
  ADValueAnimator_initialize();
  ADValueAnimator *anim = create_ADValueAnimator_init();
  [anim setObjectValuesWithNSObjectArray:values];
  [anim setEvaluatorWithADTypeEvaluator:evaluator];
  return anim;
}

float ADValueAnimator_resolveDurationScale(ADValueAnimator *self) {
  return self->mDurationScale_ >= 0.0f ? self->mDurationScale_ : ADValueAnimator_sDurationScale;
}

int64_t ADValueAnimator_getScaledDuration(ADValueAnimator *self) {
  return JreFpToLong((self->mDuration_ * ADValueAnimator_resolveDurationScale(self)));
}

int32_t ADValueAnimator_getCurrentIterationWithFloat_(ADValueAnimator *self, float fraction) {
  fraction = ADValueAnimator_clampFractionWithFloat_(self, fraction);
  double iteration = JavaLangMath_floorWithDouble_(fraction);
  if (fraction == iteration && fraction > 0) {
    iteration--;
  }
  return JreFpToInt(iteration);
}

float ADValueAnimator_getCurrentIterationFractionWithFloat_withBoolean_(ADValueAnimator *self, float fraction, bool inReverse) {
  fraction = ADValueAnimator_clampFractionWithFloat_(self, fraction);
  int32_t iteration = ADValueAnimator_getCurrentIterationWithFloat_(self, fraction);
  float currentFraction = fraction - iteration;
  return ADValueAnimator_shouldPlayBackwardWithInt_withBoolean_(self, iteration, inReverse) ? 1.0f - currentFraction : currentFraction;
}

float ADValueAnimator_clampFractionWithFloat_(ADValueAnimator *self, float fraction) {
  if (fraction < 0) {
    fraction = 0;
  }
  else if (self->mRepeatCount_ != ADValueAnimator_INFINITE) {
    fraction = JavaLangMath_minWithFloat_withFloat_(fraction, self->mRepeatCount_ + 1);
  }
  return fraction;
}

bool ADValueAnimator_shouldPlayBackwardWithInt_withBoolean_(ADValueAnimator *self, int32_t iteration, bool inReverse) {
  if (iteration > 0 && self->mRepeatMode_ == ADValueAnimator_REVERSE && (iteration < (self->mRepeatCount_ + 1) || self->mRepeatCount_ == ADValueAnimator_INFINITE)) {
    if (inReverse) {
      return (JreIntMod(iteration, 2)) == 0;
    }
    else {
      return (JreIntMod(iteration, 2)) != 0;
    }
  }
  else {
    return inReverse;
  }
}

int64_t ADValueAnimator_getFrameDelay() {
  ADValueAnimator_initialize();
  return ADAnimationHandler_getFrameDelay();
}

void ADValueAnimator_setFrameDelayWithLong_(int64_t frameDelay) {
  ADValueAnimator_initialize();
  ADAnimationHandler_setFrameDelayWithLong_(frameDelay);
}

void ADValueAnimator_startWithBoolean_(ADValueAnimator *self, bool playBackwards) {
  if (ADLooper_myLooper() == nil) {
    @throw create_ADAndroidRuntimeException_initWithNSString_(@"Animators may only be run on Looper threads");
  }
  self->mReversing_ = playBackwards;
  self->mSelfPulse_ = !self->mSuppressSelfPulseRequested_;
  if (playBackwards && self->mSeekFraction_ != -1 && self->mSeekFraction_ != 0) {
    if (self->mRepeatCount_ == ADValueAnimator_INFINITE) {
      float fraction = (float) (self->mSeekFraction_ - JavaLangMath_floorWithDouble_(self->mSeekFraction_));
      self->mSeekFraction_ = 1 - fraction;
    }
    else {
      self->mSeekFraction_ = 1 + self->mRepeatCount_ - self->mSeekFraction_;
    }
  }
  self->mStarted_ = true;
  self->mPaused_ = false;
  self->mRunning_ = false;
  self->mAnimationEndRequested_ = false;
  self->mLastFrameTime_ = -1;
  self->mFirstFrameTime_ = -1;
  self->mStartTime_ = -1;
  ADValueAnimator_addAnimationCallbackWithLong_(self, 0);
  if (self->mStartDelay_ == 0 || self->mSeekFraction_ >= 0 || self->mReversing_) {
    ADValueAnimator_startAnimation(self);
    if (self->mSeekFraction_ == -1) {
      [self setCurrentPlayTimeWithLong:0];
    }
    else {
      [self setCurrentFractionWithFloat:self->mSeekFraction_];
    }
  }
}

void ADValueAnimator_endAnimation(ADValueAnimator *self) {
  if (self->mAnimationEndRequested_) {
    return;
  }
  ADValueAnimator_removeAnimationCallback(self);
  self->mAnimationEndRequested_ = true;
  self->mPaused_ = false;
  bool notify = (self->mStarted_ || self->mRunning_) && self->mListeners_ != nil;
  if (notify && !self->mRunning_) {
    [self notifyStartListenersWithBoolean:self->mReversing_];
  }
  self->mLastFrameTime_ = -1;
  self->mFirstFrameTime_ = -1;
  self->mStartTime_ = -1;
  self->mRunning_ = false;
  self->mStarted_ = false;
  [self notifyEndListenersWithBoolean:self->mReversing_];
  self->mReversing_ = false;
  if (ADTrace_isTagEnabledWithLong_(ADTrace_TRACE_TAG_VIEW)) {
    ADTrace_asyncTraceEndWithInt_withNSString_withInt_(ADTrace_TRACE_TAG_VIEW, [self getNameForTrace], JavaLangSystem_identityHashCodeWithId_(self));
  }
}

void ADValueAnimator_startAnimation(ADValueAnimator *self) {
  if (ADTrace_isTagEnabledWithLong_(ADTrace_TRACE_TAG_VIEW)) {
    ADTrace_asyncTraceBeginWithInt_withNSString_withInt_(ADTrace_TRACE_TAG_VIEW, [self getNameForTrace], JavaLangSystem_identityHashCodeWithId_(self));
  }
  self->mAnimationEndRequested_ = false;
  [self initAnimation];
  self->mRunning_ = true;
  if (self->mSeekFraction_ >= 0) {
    self->mOverallFraction_ = self->mSeekFraction_;
  }
  else {
    self->mOverallFraction_ = 0.0f;
  }
  [self notifyStartListenersWithBoolean:self->mReversing_];
}

bool ADValueAnimator_isPulsingInternal(ADValueAnimator *self) {
  return self->mLastFrameTime_ >= 0;
}

bool ADValueAnimator_doAnimationFrameWithLong_(ADValueAnimator *self, int64_t frameTime) {
  if (self->mStartTime_ < 0) {
    self->mStartTime_ = self->mReversing_ ? frameTime : frameTime + JreFpToLong((self->mStartDelay_ * ADValueAnimator_resolveDurationScale(self)));
  }
  if (self->mPaused_) {
    self->mPauseTime_ = frameTime;
    ADValueAnimator_removeAnimationCallback(self);
    return false;
  }
  else if (self->mResumed_) {
    self->mResumed_ = false;
    if (self->mPauseTime_ > 0) {
      self->mStartTime_ += (frameTime - self->mPauseTime_);
    }
  }
  if (!self->mRunning_) {
    if (self->mStartTime_ > frameTime && self->mSeekFraction_ == -1) {
      return false;
    }
    else {
      self->mRunning_ = true;
      ADValueAnimator_startAnimation(self);
    }
  }
  if (self->mLastFrameTime_ < 0) {
    if (self->mSeekFraction_ >= 0) {
      int64_t seekTime = JreFpToLong((ADValueAnimator_getScaledDuration(self) * self->mSeekFraction_));
      self->mStartTime_ = frameTime - seekTime;
      self->mSeekFraction_ = -1;
    }
    self->mStartTimeCommitted_ = false;
  }
  self->mLastFrameTime_ = frameTime;
  int64_t currentTime = JavaLangMath_maxWithLong_withLong_(frameTime, self->mStartTime_);
  bool finished = [self animateBasedOnTimeWithLong:currentTime];
  if (finished) {
    ADValueAnimator_endAnimation(self);
  }
  return finished;
}

void ADValueAnimator_addOneShotCommitCallback(ADValueAnimator *self) {
  if (!self->mSelfPulse_) {
    return;
  }
  [((ADAnimationHandler *) nil_chk([self getAnimationHandler])) addOneShotCommitCallbackWithADAnimationHandler_AnimationFrameCallback:self];
}

void ADValueAnimator_removeAnimationCallback(ADValueAnimator *self) {
  if (!self->mSelfPulse_) {
    return;
  }
  [((ADAnimationHandler *) nil_chk([self getAnimationHandler])) removeCallbackWithADAnimationHandler_AnimationFrameCallback:self];
}

void ADValueAnimator_addAnimationCallbackWithLong_(ADValueAnimator *self, int64_t delay) {
  if (!self->mSelfPulse_) {
    return;
  }
  [((ADAnimationHandler *) nil_chk([self getAnimationHandler])) addAnimationFrameCallbackWithADAnimationHandler_AnimationFrameCallback:self withLong:delay];
}

int32_t ADValueAnimator_getCurrentAnimationsCount() {
  ADValueAnimator_initialize();
  return ADAnimationHandler_getAnimationCount();
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ADValueAnimator)

J2OBJC_NAME_MAPPING(ADValueAnimator, "r.android.animation", "AD")

@implementation ADValueAnimator_RepeatMode

+ (const J2ObjcClassInfo *)__metadata {
  static const void *ptrTable[] = { "LADValueAnimator;", (void *)&ADValueAnimator_RepeatMode__Annotations$0 };
  static const J2ObjcClassInfo _ADValueAnimator_RepeatMode = { "RepeatMode", "r.android.animation", ptrTable, NULL, NULL, 7, 0x2609, 0, 0, 0, -1, -1, -1, 1 };
  return &_ADValueAnimator_RepeatMode;
}

@end

IOSObjectArray *ADValueAnimator_RepeatMode__Annotations$0() {
  return [IOSObjectArray arrayWithObjects:(id[]){ create_JavaLangAnnotationRetention(JreLoadEnum(JavaLangAnnotationRetentionPolicy, SOURCE)) } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(ADValueAnimator_RepeatMode)

@implementation ADValueAnimator_AnimatorUpdateListener

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x401, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(onAnimationUpdateWithADValueAnimator:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "onAnimationUpdate", "LADValueAnimator;" };
  static const J2ObjcClassInfo _ADValueAnimator_AnimatorUpdateListener = { "AnimatorUpdateListener", "r.android.animation", ptrTable, methods, NULL, 7, 0x609, 1, 0, 1, -1, -1, -1, -1 };
  return &_ADValueAnimator_AnimatorUpdateListener;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(ADValueAnimator_AnimatorUpdateListener)

@implementation ADValueAnimator_DurationScaleChangeListener

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x401, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(onChangedWithFloat:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "onChanged", "F", "LADValueAnimator;" };
  static const J2ObjcClassInfo _ADValueAnimator_DurationScaleChangeListener = { "DurationScaleChangeListener", "r.android.animation", ptrTable, methods, NULL, 7, 0x609, 1, 0, 2, -1, -1, -1, -1 };
  return &_ADValueAnimator_DurationScaleChangeListener;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(ADValueAnimator_DurationScaleChangeListener)
